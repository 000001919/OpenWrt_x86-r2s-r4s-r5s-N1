From 4b32fa062bdccd6392c8929b4952b502725b1b78 Mon Sep 17 00:00:00 2001
From: jjm2473 <1129525450@qq.com>
Date: Mon, 16 Nov 2020 16:33:36 +0800
Subject: [PATCH 01/20] mt7615: try wext and cfg80211

---
 package/base-files/files/etc/init.d/boot      |    1 +
 package/feeds/custom/mt7615d/Makefile      |   36 +-
 .../files/lib/netifd/wireless/mt_dbdc.sh      |  879 ++++++++++
 .../drivers/mt7615d/files/lib/wifi/mt_dbdc.sh |   76 +
 .../src/mt_wifi/embedded/common/cmm_info.c    |    5 +-
 .../mt_wifi/embedded/common/multi_profile.c   |    6 +-
 .../mt_wifi/embedded/include/cfg80211extr.h   |    5 +
 .../src/mt_wifi/embedded/include/l1profile.h  |   61 +-
 .../src/mt_wifi/embedded/include/rtmp.h       |    1 +
 .../src/mt_wifi/embedded/include/rtmp_comm.h  |    2 +-
 .../mt7615d/src/mt_wifi/os/linux/ap_ioctl.c   |   82 +-
 .../src/mt_wifi/os/linux/cfg80211/cfg80211.c  |   29 +
 .../mt_wifi/os/linux/cfg80211/cfg80211_p2p.c  | 1261 +++++++++++++-
 .../drivers/mt7615d/src/mt_wifi_ap/Makefile   |   22 +-
 .../mt7615d/src/wlan_cfg/mt7622/Readme.txt    |    2 +-
 package/network/utils/iwinfo/Makefile         |    1 +
 .../utils/iwinfo/patches/001-ralink.patch     | 1546 +++++++++++++++++
 target/linux/ramips/image/mt7621.mk           |    2 +-
 18 files changed, 3917 insertions(+), 100 deletions(-)
 create mode 100644 package/feeds/custom/mt7615d/files/lib/netifd/wireless/mt_dbdc.sh
 create mode 100644 package/feeds/custom/mt7615d/files/lib/wifi/mt_dbdc.sh
 create mode 100644 package/network/utils/iwinfo/patches/001-ralink.patch

diff --git a/package/base-files/files/etc/init.d/boot b/package/base-files/files/etc/init.d/boot
index 21aecde615d..d947895cfa8 100755
--- a/package/base-files/files/etc/init.d/boot
+++ b/package/base-files/files/etc/init.d/boot
@@ -42,6 +42,7 @@ boot() {
 	[ ! -f /etc/config/wireless ] && {
 		# compat for bcm47xx and mvebu
 		sleep 1
+		/sbin/wifi config
 	}
 
 	/bin/config_generate
diff --git a/package/feeds/custom/mt7615d/Makefile b/package/feeds/custom/mt7615d/Makefile
index 931932d06d7..37bcccd118c 100644
--- a/package/feeds/custom/mt7615d/Makefile
+++ b/package/feeds/custom/mt7615d/Makefile
@@ -10,7 +10,9 @@ PKG_NAME:=mt7615d
 P4REV:=8
 PKG_VERSION:=5.0.4.0
 
-PKG_BUILD_DIR:=$(KERNEL_BUILD_DIR)/$(PKG_NAME)
+PKG_BUILD_PARALLEL:=1
+
+# PKG_BUILD_DIR:=$(KERNEL_BUILD_DIR)/$(PKG_NAME)
 PKG_KCONFIG:= \
 	AP_SUPPORT \
 	RT_FIRST_CARD \
@@ -171,22 +173,23 @@ PKG_KCONFIG:= \
 	DSCP_PRI_SUPPORT \
 	PCIE_ASPM_DYM_CTRL_SUPPORT \
 
-PKG_CONFIG_DEPENDS:=$(foreach c, $(PKG_KCONFIG),$(if $(CONFIG_MTK_$c),CONFIG_$(c)))
+PKG_CONFIG_DEPENDS:=$(foreach c, $(PKG_KCONFIG), CONFIG_MTK_$(c) )
 
 include $(INCLUDE_DIR)/package.mk
 
-TAR_CMD=$(HOST_TAR) -C $(1)/ $(TAR_OPTIONS)
+# TAR_CMD=$(HOST_TAR) -C $(1)/ $(TAR_OPTIONS)
 
 define KernelPackage/mt7615d
   CATEGORY:=Kernel modules
   TITLE:=MTK wifi AP driver
-  DEPENDS:=@TARGET_ramips
+  DEPENDS:=@TARGET_ramips +maccalc +MTK_CFG80211_SUPPORT:kmod-cfg80211 +@DRIVER_11AC_SUPPORT +@DRIVER_11N_SUPPORT +@DRIVER_11W_SUPPORT
 ifneq ($(CONFIG_MTK_WHNAT_SUPPORT), )
   FILES:=$(PKG_BUILD_DIR)/mt_wifi_ap/mt_wifi.ko \
 	$(PKG_BUILD_DIR)/mt_wifi/embedded/tools/plug_in/whnat/mt_whnat.ko
 else
   FILES:=$(PKG_BUILD_DIR)/mt_wifi_ap/mt_wifi.ko
 endif
+  AUTOLOAD:=$(call AutoProbe,mt_wifi)
   SUBMENU:=Wireless Drivers
   MENU:=1
 endef
@@ -195,17 +198,32 @@ define KernelPackage/mt7615d/config
 	source "$(SOURCE)/config.in"
 endef
 
+NOSTDINC_FLAGS = \
+	-I$(STAGING_DIR)/usr/include/mac80211-backport/uapi \
+	-I$(STAGING_DIR)/usr/include/mac80211-backport \
+	-I$(STAGING_DIR)/usr/include/mac80211/uapi \
+	-I$(STAGING_DIR)/usr/include/mac80211 \
+	-include backport/autoconf.h \
+	-include backport/backport.h
+
 define Build/Compile
-	$(MAKE) -C "$(LINUX_DIR)" V=1 \
-		CROSS_COMPILE="$(TARGET_CROSS)" \
-		ARCH="$(LINUX_KARCH)" \
-		M="$(PKG_BUILD_DIR)/mt_wifi_ap" \
+	+$(MAKE) $(PKG_JOBS) -C "$(LINUX_DIR)" \
+		$(KERNEL_MAKE_FLAGS) \
 		$(foreach c, $(PKG_KCONFIG),$(if $(CONFIG_MTK_$c),CONFIG_$(c)=$(CONFIG_MTK_$(c)))) \
+		M="$(PKG_BUILD_DIR)/mt_wifi_ap" \
+		NOSTDINC_FLAGS="$(NOSTDINC_FLAGS)" \
+		V=1 \
 		modules
 endef
 
+define Build/Install
+        :
+endef
+
 define KernelPackage/mt7615d/install
-	$(INSTALL_DIR) $(1)/etc/wireless/mt7615/
+	$(INSTALL_DIR) $(1)/lib/wifi $(1)/lib/netifd/wireless
+	$(INSTALL_DATA) ./files/lib/wifi/mt_dbdc.sh $(1)/lib/wifi
+	$(INSTALL_BIN) ./files/lib/netifd/wireless/mt_dbdc.sh $(1)/lib/netifd/wireless
 endef
 
 $(eval $(call KernelPackage,mt7615d))
diff --git a/package/feeds/custom/mt7615d/files/lib/netifd/wireless/mt_dbdc.sh b/package/feeds/custom/mt7615d/files/lib/netifd/wireless/mt_dbdc.sh
new file mode 100644
index 00000000000..5c1072f7288
--- /dev/null
+++ b/package/feeds/custom/mt7615d/files/lib/netifd/wireless/mt_dbdc.sh
@@ -0,0 +1,879 @@
+#!/bin/sh
+#
+# Copyright (c) 2013-2015 D-Team Technology Co.,Ltd. ShenZhen
+# Copyright (c) 2005-2015, lintel <lintel.huang@gmail.com>
+# Copyright (c) 2013, Hoowa <hoowa.sun@gmail.com>
+# Copyright (c) 2015-2017, GuoGuo <gch981213@gmail.com>
+#
+# 	netifd config script for MT7615 DBDC mode.
+#
+# 	嘿，对着屏幕的哥们,为了表示对原作者辛苦工作的尊重，任何引用跟借用都不允许你抹去所有作者的信息,请保留这段话。
+#
+. /lib/netifd/netifd-wireless.sh
+
+init_wireless_driver "$@"
+
+#Default configurations
+RTWIFI_PROFILE_DIR="/tmp/profiles/"
+RTWIFI_PROFILE_PATH=""
+RTWIFI_CMD_PATH=""
+RTWIFI_CMD_OPATH=""
+APCLI_IF=""
+APCLI_APCTRL=""
+WIFI_OP_LOCK=$RTWIFI_PROFILE_DIR"mt_dbdc.lock"
+RTWIFI_IFPREFIX=""
+RTWIFI_DEF_BAND=""
+RTWIFI_FORCE_HT=0
+RTWIFI_DEF_MAX_BSSID=4
+
+mt_cmd() {
+	echo "$@" >> $RTWIFI_CMD_PATH
+	eval $@
+}
+
+#读取device相关设置项并写入json
+drv_mt_dbdc_init_device_config() { 
+	config_add_string channel hwmode htmode country macaddr
+	config_add_int beacon_int chanbw frag rts txburst
+	config_add_int rxantenna txantenna antenna_gain txpower distance wmm
+	config_add_boolean greenap diversity noscan ht_coex smart
+	config_add_int powersave
+	config_add_int maxassoc
+	config_add_boolean hidessid bndstrg
+	
+	config_add_boolean \
+		rxldpc \
+		short_gi_80 \
+		short_gi_160 \
+		tx_stbc_2by1 \
+		su_beamformer \
+		su_beamformee \
+		mu_beamformer \
+		mu_beamformee \
+		vht_txop_ps \
+		htc_vht \
+		rx_antenna_pattern \
+		tx_antenna_pattern
+	config_add_int vht_max_a_mpdu_len_exp vht_max_mpdu vht_link_adapt vht160 rx_stbc tx_stbc
+	
+	config_add_boolean \
+		ldpc \
+		greenfield \
+		short_gi_20 \
+		short_gi_40 \
+		dsss_cck_40
+}
+
+#读取iface相关设置项并写入json
+drv_mt_dbdc_init_iface_config() { 
+	config_add_boolean disabled
+	config_add_string mode bssid ssid encryption
+	config_add_boolean hidden isolated doth ieee80211r
+	config_add_string key key1 key2 key3 key4
+	config_add_string wps
+	config_add_string pin
+	config_add_string macpolicy
+	config_add_array maclist
+	
+	config_add_boolean wds
+	config_add_int max_listen_int
+	config_add_int dtim_period
+	config_add_int rssikick rssiassoc
+	config_add_string wdsenctype wdskey wdsphymode
+	config_add_int wdswepid wdstxmcs
+}
+
+get_wep_key_type() {
+	local KeyLen=$(expr length "$1")
+	if [ $KeyLen -eq 10 ] || [ $KeyLen -eq 26 ]
+	then
+		echo 0
+	else
+		echo 1
+	fi	
+}
+
+mt_dbdc_ap_vif_pre_config() {
+	local name="$1"
+
+	json_select config
+	json_get_vars disabled encryption key key1 key2 key3 key4 ssid mode wps pin hidden macpolicy
+	json_get_values maclist maclist
+	json_select ..
+	[ "$disabled" == "1" ] && return
+	echo "Generating ap config for interface ra${RTWIFI_IFPREFIX}${ApBssidNum}"
+	ifname="ra${RTWIFI_IFPREFIX}${ApBssidNum}"
+
+	#MAC过滤方式相关设定 由于编号问题......我扔在这了......
+	ra_maclist="${maclist// /;};"
+	case "$macpolicy" in
+	allow)
+		echo "Interface ${ifname} has MAC Policy.Allow list:${ra_maclist}"
+		echo "AccessPolicy${ApBssidNum}=1" >> $RTWIFI_PROFILE_PATH
+		echo "AccessControlList$ApBssidNum=${ra_maclist}" >> $RTWIFI_PROFILE_PATH
+	;;
+	deny)
+		echo "Interface ${ifname} has MAC Policy.Deny list:${ra_maclist}"
+		echo "AccessPolicy${ApBssidNum}=2" >> $RTWIFI_PROFILE_PATH
+		echo "AccessControlList${ApBssidNum}=${ra_maclist}" >> $RTWIFI_PROFILE_PATH
+	;;
+	esac
+
+	let ApBssidNum+=1
+	echo "SSID$ApBssidNum=${ssid}" >> $RTWIFI_PROFILE_PATH #SSID
+	case "$encryption" in #加密方式
+	wpa*|psk*|WPA*|Mixed|mixed)
+		local enc
+		local crypto
+		case "$encryption" in
+			Mixed|mixed|psk+psk2|psk-mixed*)
+				enc=WPAPSKWPA2PSK
+			;;
+			WPA2*|wpa2*|psk2*)
+				enc=WPA2PSK
+			;;
+			WPA*|WPA1*|wpa*|wpa1*|psk*)
+				enc=WPAPSK
+			;;
+			esac
+			crypto="AES"
+		case "$encryption" in
+			*tkip+aes*|*tkip+ccmp*|*aes+tkip*|*ccmp+tkip*)
+				crypto="TKIPAES"
+			;;
+			*aes*|*ccmp*)
+				crypto="AES"
+			;;
+			*tkip*) 
+				crypto="TKIP"
+				echo "Warning!!! TKIP is not support in 802.11n 40Mhz!!!"
+			;;
+			esac
+				ApAuthMode="${ApAuthMode}${enc};"
+				ApEncrypType="${ApEncrypType}${crypto};"
+				ApDefKId="${ApDefKId}2;"
+			echo "WPAPSK$ApBssidNum=${key}" >> $RTWIFI_PROFILE_PATH
+	;;
+	WEP|wep|wep-open|wep-shared)
+		if [ "$encryption" == "wep-shared" ]; then
+			ApAuthMode="${ApAuthMode}SHARED;"
+		else  
+			ApAuthMode="${ApAuthMode}OPEN;"
+		fi
+		ApEncrypType="${ApEncrypType}WEP;"
+		K1Tp=$(get_wep_key_type "$key1")
+		K2Tp=$(get_wep_key_type "$key2")
+		K3Tp=$(get_wep_key_type "$key3")
+		K4Tp=$(get_wep_key_type "$key4")
+
+		[ $K1Tp -eq 1 ] && key1=$(echo $key1 | cut -d ':' -f 2- )
+		[ $K2Tp -eq 1 ] && key2=$(echo $key2 | cut -d ':' -f 2- )
+		[ $K3Tp -eq 1 ] && key3=$(echo $key3 | cut -d ':' -f 2- )
+		[ $K4Tp -eq 1 ] && key4=$(echo $key4 | cut -d ':' -f 2- )
+		echo "Key1Str${ApBssidNum}=${key1}" >> $RTWIFI_PROFILE_PATH
+		echo "Key2Str${ApBssidNum}=${key2}" >> $RTWIFI_PROFILE_PATH
+		echo "Key3Str${ApBssidNum}=${key3}" >> $RTWIFI_PROFILE_PATH
+		echo "Key4Str${ApBssidNum}=${key4}" >> $RTWIFI_PROFILE_PATH
+		ApDefKId="${ApDefKId}${key};"
+		;;
+	none|open)
+		ApAuthMode="${ApAuthMode}OPEN;"
+		ApEncrypType="${ApEncrypType}NONE;"
+		ApDefKId="${ApDefKId}1;"
+		;;
+	esac
+	ApHideESSID="${ApHideESSID}${hidden:-0};"
+	ApK1Tp="${ApK1Tp}${K1Tp:-0};"
+	ApK2Tp="${ApK2Tp}${K2Tp:-0};"
+	ApK3Tp="${ApK3Tp}${K3Tp:-0};"
+	ApK4Tp="${ApK4Tp}${K4Tp:-0};"
+}
+
+mt_dbdc_wds_vif_pre_config() {
+	local name="$1"
+
+	json_select config
+	json_get_vars disabled bssid wdsenctype wdskey wdswepid wdsphymode wdstxmcs
+	set_default wdswepid 1
+	set_default wdstxmcs 33
+	set_default wdsphymode "GREENFIELD"
+	json_select ..
+	[ "$disabled" == "1" ] && return
+	[ $WDSBssidNum -gt 3 ] && return
+	echo "Generating WDS config for interface wds${RTWIFI_IFPREFIX}${WDSBssidNum}"
+	WDSEN=1
+	WDSList="${WDSList}${bssid};"
+	WDSEncType="${WDSEncType}${wdsenctype};"
+	WDSDefKeyID="${WDSDefKeyID}${wdswepid};"
+	WDSPhyMode="${WDSPhyMode}${wdsphymode};"
+	WDSTxMCS="${WDSTxMCS}${wdstxmcs};"
+	echo "Wds${ApBssidNum}Key=${wdskey}" >> $RTWIFI_PROFILE_PATH #WDS Key
+	let WDSBssidNum+=1
+}
+
+mt_dbdc_wds_vif_post_config() {
+	local name="$1"
+	json_select config
+	json_get_vars disabled
+	json_select ..
+
+	[ "$disabled" == "1" ] && return
+	[ $WDSBssidNum -gt 3 ] && return
+
+	ifname="wds${RTWIFI_IFPREFIX}${WDSBssidNum}"
+	ifconfig $ifname up
+	echo "WDS interface wds${RTWIFI_IFPREFIX}${WDSBssidNum} now up."
+	wireless_add_vif "$name" "$ifname"
+	let WDSBssidNum+=1
+}
+
+mt_dbdc_ap_vif_post_config() {
+	local name="$1"
+
+	json_select config
+	json_get_vars disabled encryption key key1 key2 key3 key4 ssid mode wps pin isolated doth hidden rssikick rssiassoc ieee80211r
+	json_select ..
+
+	[ "$disabled" == "1" ] && return
+	
+	[ $ApIfCNT -gt $RTWIFI_DEF_MAX_BSSID ] && return 
+	
+	ifname="ra${RTWIFI_IFPREFIX}${ApIfCNT}"
+	let ApIfCNT+=1
+
+	ifconfig $ifname up
+	echo "Interface $ifname now up."
+	mt_cmd iwpriv $ifname set NoForwarding=${isolated:-0}
+	mt_cmd iwpriv $ifname set IEEE80211H=${doth:-0}
+	if [ "$wps" == "pbc" ]  && [ "$encryption" != "none" ]; then
+		echo "Enable WPS for ${ifname}."
+		mt_cmd iwpriv $ifname set WscConfMode=4
+		mt_cmd iwpriv $ifname set WscConfStatus=2
+		mt_cmd iwpriv $ifname set WscMode=2
+		mt_cmd iwpriv $ifname set WscV2Support=0
+	else
+		mt_cmd iwpriv $ifname set WscConfMode=0
+	fi
+	[ -n "$rssikick" ]  && [ "$rssikick" != "0" ] && mt_cmd iwpriv $ifname set KickStaRssiLow=$rssikick
+	[ -n "$rssiassoc" ]  && [ "$rssiassoc" != "0" ] && mt_cmd iwpriv $ifname set AssocReqRssiThres=$rssiassoc
+	[ -n "$ieee80211r" ]  && [ "$ieee80211r" != "0" ] && mt_cmd iwpriv $ifname set ftenable=1
+	wireless_add_vif "$name" "$ifname"
+}
+
+mt_dbdc_sta_vif_connect() {
+	local name="$1"
+
+	json_select config
+	json_get_vars disabled encryption key key1 key2 key3 key4 ssid mode bssid
+	json_select ..
+
+	[ $stacount -gt 1 ] && {
+		return
+	}
+
+	[ "$disabled" == "1" ] && return
+	[ -z "${RTWIFI_IFPREFIX}" ] && [ "$ApIfCNT" == "0" ] && {
+		#FIXME: need ra0 up before apcli0 start
+		ifconfig ra${RTWIFI_IFPREFIX}0 up
+		ifconfig $APCLI_IF up
+		iwpriv ra${RTWIFI_IFPREFIX}0 set DisConnectAllSta=1 2>/dev/null
+		ifconfig ra${RTWIFI_IFPREFIX}0 down
+	}
+	let stacount+=1
+
+	killall  $APCLI_APCTRL
+	[ ! -z "$key" ] && APCTRL_KEY_ARG="-k"
+	[ ! -z "$bssid" ] && APCTRL_BSS_ARG="-b $(echo $bssid | tr 'A-Z' 'a-z')"
+	mt_cmd $APCLI_APCTRL ra${RTWIFI_IFPREFIX}0 connect -s "$ssid" $APCTRL_BSS_ARG $APCTRL_KEY_ARG "$key"
+
+	wireless_add_vif "$name" "$APCLI_IF"
+}
+
+get_if_stat() {
+	[ ! -z "$1" ] && [ -d "/sys/class/net/$1" ] && cat /sys/class/net/$1/operstate
+}
+
+mt_dbdc_vif_down() {
+	phy_name=${1}
+	killall -9 -q apcli_2g
+	killall -9 -q apcli_5g
+	case "$phy_name" in
+		rax)
+			for vif in ra0 ra1 ra2 ra3 ra4 ra5 ra6 ra7 wds0 wds1 wds2 wds3 apcli0; do
+				[ "$(get_if_stat $vif)" != "down" ] && ifconfig $vif down && echo $vif
+			done
+		;;
+		ra)
+			for vif in rax0 rax1 rax2 rax3 rax4 rax5 rax6 rax7 wdsx0 wdsx1 wdsx2 wdsx3 apclix0; do
+				[ "$(get_if_stat $vif)" != "down" ] && ifconfig $vif down && echo $vif
+			done
+		;;
+	esac
+}
+
+drv_mt_dbdc_cleanup() {
+	return
+}
+
+drv_mt_dbdc_teardown() {
+	phy_name=${1}
+	case "$phy_name" in
+		ra)
+			killall -9 -q apcli_2g
+			for vif in ra0 ra1 ra2 ra3 ra4 ra5 ra6 ra7 wds0 wds1 wds2 wds3 apcli0; do
+				iwpriv $vif set DisConnectAllSta=1
+				[ -d "/sys/class/net/$vif" ] && ifconfig $vif down
+			done
+		;;
+		rax)
+			killall -9 -q apcli_5g
+			for vif in rax0 rax1 rax2 rax3 rax4 rax5 rax6 rax7 wdsx0 wdsx1 wdsx2 wdsx3 apclix0; do
+				iwpriv $vif set DisConnectAllSta=1
+				[ -d "/sys/class/net/$vif" ] && ifconfig $vif down
+			done
+		;;
+	esac
+}
+
+#接口启动
+drv_mt_dbdc_setup() {
+	json_select config
+	json_get_vars main_if macaddr channel mode hwmode wmm htmode \
+		txpower country macpolicy maclist greenap \
+		diversity frag rts txburst distance hidden \
+		disabled maxassoc macpolicy maclist noscan ht_coex smart #device所有配置项
+		
+	json_get_vars \
+			ldpc:1 \
+			greenfield:0 \
+			short_gi_20:1 \
+			short_gi_40:1 \
+			tx_stbc:1 \
+			rx_stbc:3 \
+			max_amsdu:1 \
+			dsss_cck_40:1
+			
+	json_get_vars \
+			rxldpc:1 \
+			short_gi_80:1 \
+			short_gi_160:1 \
+			tx_stbc_2by1:1 \
+			su_beamformer:1 \
+			su_beamformee:1 \
+			mu_beamformer:1 \
+			mu_beamformee:1 \
+			vht_txop_ps:1 \
+			htc_vht:1 \
+			rx_antenna_pattern:1 \
+			tx_antenna_pattern:1 \
+			vht_max_a_mpdu_len_exp:7 \
+			vht_max_mpdu:11454 \
+			rx_stbc:4 \
+			vht_link_adapt:3 
+
+	json_select ..
+
+	phy_name=${1}
+	wireless_set_data phy=${phy_name}
+	case "$phy_name" in
+		ra)
+			WirelessMode=9
+			APCLI_IF="apcli0"
+			APCLI_APCTRL="apcli_2g"
+			RTWIFI_IFPREFIX=""
+			RTWIFI_DEF_BAND="g"
+			RTWIFI_PROFILE_PATH="${RTWIFI_PROFILE_DIR}mt_dbdc_2g.dat"
+			RTWIFI_CMD_PATH="${RTWIFI_PROFILE_DIR}mt_dbdc_cmd_2g.sh"
+			RTWIFI_CMD_OPATH="${RTWIFI_PROFILE_DIR}mt_dbdc_cmd_5g.sh"
+		;;
+		rax)
+			WirelessMode=14
+			APCLI_IF="apclix0"
+			APCLI_APCTRL="apcli_5g"
+			RTWIFI_IFPREFIX="x"
+			RTWIFI_DEF_BAND="a"
+			RTWIFI_PROFILE_PATH="${RTWIFI_PROFILE_DIR}mt_dbdc_5g.dat"
+			RTWIFI_CMD_PATH="${RTWIFI_PROFILE_DIR}mt_dbdc_cmd_5g.sh"
+			RTWIFI_CMD_OPATH="${RTWIFI_PROFILE_DIR}mt_dbdc_cmd_2g.sh"
+		;;
+		*)
+			echo "Unknown phy:$phy_name"
+			return 1
+	esac
+
+#检查配置文件目录是否存在，否则创建目录
+	[ ! -d $RTWIFI_PROFILE_DIR ] && mkdir $RTWIFI_PROFILE_DIR
+	echo > $RTWIFI_CMD_PATH
+
+	hwmode=${hwmode##11}
+	case "$hwmode" in
+		a)
+			WirelessMode=14
+			ITxBfEn=1
+			HT_HTC=1
+		;;
+		g)
+			WirelessMode=9
+			ITxBfEn=0
+			HT_HTC=1
+		;;
+		*) 
+			echo "Unknown wireless mode.Use default value:${WirelessMode}"
+			hwmode=${RTWIFI_DEF_BAND}
+		;;
+	esac
+	
+#HT默认模式设定
+	HT_BW=1  #允许HT40
+	HT_CE=1  #允许HT20/40共存
+	HT_DisallowTKIP=0 #是否允许TKIP加密
+	HT_GI=1 #HT_SHORT_GI
+	VHT_SGI=1 #VHT_SHORT_GI
+	#HT_MIMOPSMode用于省电模式设置
+	#HT_MIMOPSMode=3
+	
+#VHT默认模式设定
+	VHT_BW=1 #允许VHT
+	VHT_DisallowNonVHT=0 #是否禁止非VHT客户端连接，VHT80 only
+	
+	[ "$short_gi_20" == "0" -o "$short_gi_40" == "0" ] && HT_GI=0
+	[ "$short_gi_80" == "0" -o "$short_gi_160" == "0" ] && VHT_SGI=0
+	
+	case "$htmode" in
+		HT20 |\
+		VHT20) 
+			HT_BW=0
+			VHT_BW=0
+		;;
+		HT40 |\
+		VHT40)
+			HT_BW=1
+			VHT_BW=0
+			VHT_DisallowNonVHT=0
+		;;
+		HT80 |\
+		VHT80)
+			HT_BW=1
+			VHT_BW=1
+		;;
+		
+		VHT160)
+			echo "only VHT80 support!!"
+			HT_BW=1
+			VHT_BW=1
+		;;
+		*) 
+		echo "Unknown HT Mode."
+		;;
+	esac
+	
+#仅HT20以外才需要设置的参数
+     [ "$htmode" != "HT20" ] && {
+#强制HT40/VHT80
+		[ "$noscan" == "1" ] && HT_CE=0 && RTWIFI_FORCE_HT=1
+#HT HTC
+		[ "$ht_htc" == "1" ] && HT_HTC=1
+    }
+
+#自动处理CountryRegion:指定信道的时候支持全频段
+      [ "$channel" != "auto" ] && {
+		#CountryRegion CN
+		countryregion=5
+		countryregion_a=7
+      }
+
+#信道相关
+	case "$hwmode" in
+		a)
+			EXTCHA=1
+			[ "$channel" != "auto" ] && [ "$channel" != "0" ] && [ "$(( ($channel / 4) % 2 ))" == "0" ] && EXTCHA=0
+			[ "$channel" == "165" ] && EXTCHA=0
+			[ "$channel" == "auto" -o "$channel" == "0" ] && {
+				#CountryRegion CN
+				countryregion=1
+				countryregion_a=0
+				channel=149
+				AutoChannelSelect=2
+			}
+			ACSSKIP="36;38;40;42;44;46;48;52;56;60;64;100;104;108;112;116;120;124;128;132;136;140;165"
+		;;
+		g)
+			EXTCHA=0
+			[ "$channel" != "auto" ] && [ "$channel" != "0" ] && [ "$channel" -lt "7" ] && EXTCHA=1
+			[ "$channel" == "auto" -o "$channel" == "0" ] && {
+				channel=6
+				AutoChannelSelect=2
+				countryregion=1
+			}
+			ACSSKIP="12;13;14"
+		;;
+	esac
+
+#设备配置文件生成
+	cat > $RTWIFI_PROFILE_PATH <<EOF
+#The word of "Default" must not be removed
+Default
+DBDC_MODE=1
+BssidNum=${RTWIFI_DEF_MAX_BSSID}
+MacAddress=${macaddr}
+CountryRegion=${countryregion:-5}
+CountryRegionABand=${countryregion_a:-7}
+CountryCode=${country:-CN}
+WirelessMode=${WirelessMode}
+G_BAND_256QAM=1
+FixedTxMode=
+TxRate=0
+Channel=${channel}
+BasicRate=15
+BeaconPeriod=100
+DtimPeriod=1
+PERCENTAGEenable=1
+TxPower=${txpower:-100}
+SKUenable=1
+BFBACKOFFenable=0
+CalCacheApply=0
+DisableOLBC=0
+BGProtection=0
+TxAntenna=
+RxAntenna=
+TxPreamble=1
+RTSThreshold=${rts:-2347}
+FragThreshold=${frag:-2346}
+TxBurst=${txburst:-0}
+PktAggregate=1
+AutoProvisionEn=0
+FreqDelta=0
+TurboRate=0
+WmmCapable=${wmm:-0}
+APAifsn=3;7;1;1
+APCwmin=4;4;3;2
+APCwmax=6;10;4;3
+APTxop=0;0;94;47
+APACM=0;0;0;0
+BSSAifsn=3;7;2;2
+BSSCwmin=4;4;3;2
+BSSCwmax=10;10;4;3
+BSSTxop=0;0;94;47
+BSSACM=0;0;0;0
+AckPolicy=0;0;0;0
+APSDCapable=0
+DLSCapable=0
+NoForwarding=0
+NoForwardingBTNBSSID=0
+ShortSlot=1
+AutoChannelSelect=${AutoChannelSelect:-0}
+IEEE8021X=0
+IEEE80211H=0
+CarrierDetect=0
+ITxBfEn=${ITxBfEn}
+PreAntSwitch=
+PhyRateLimit=0
+DebugFlags=0
+ETxBfEnCond=${ITxBfEn}
+ITxBfTimeout=0
+ETxBfTimeout=0
+ETxBfNoncompress=0
+ETxBfIncapable=0
+MUTxRxEnable=3
+DfsEnable=0
+DfsZeroWait=0
+DfsZeroWaitCacTime=255
+FineAGC=0
+StreamMode=0
+StreamModeMac0=
+StreamModeMac1=
+StreamModeMac2=
+StreamModeMac3=
+CSPeriod=6
+RDRegion=
+StationKeepAlive=0
+DfsLowerLimit=0
+DfsUpperLimit=0
+DfsOutdoor=0
+SymRoundFromCfg=0
+BusyIdleFromCfg=0
+DfsRssiHighFromCfg=0
+DfsRssiLowFromCfg=0
+DFSParamFromConfig=0
+FCCParamCh0=
+FCCParamCh1=
+FCCParamCh2=
+FCCParamCh3=
+CEParamCh0=
+CEParamCh1=
+CEParamCh2=
+CEParamCh3=
+JAPParamCh0=
+JAPParamCh1=
+JAPParamCh2=
+JAPParamCh3=
+JAPW53ParamCh0=
+JAPW53ParamCh1=
+JAPW53ParamCh2=
+JAPW53ParamCh3=
+FixDfsLimit=0
+LongPulseRadarTh=0
+AvgRssiReq=0
+DFS_R66=0
+BlockCh=
+PreAuth=0
+WapiPsk1=0123456789
+WapiPsk2=
+WapiPsk3=
+WapiPsk4=
+WapiPsk5=
+WapiPsk6=
+WapiPsk7=
+WapiPsk8=
+WapiPskType=0
+Wapiifname=
+WapiAsCertPath=
+WapiUserCertPath=
+WapiAsIpAddr=
+WapiAsPort=
+RekeyMethod=DISABLE
+RekeyInterval=3600
+PMKCachePeriod=10
+MeshAutoLink=0
+MeshAuthMode=
+MeshEncrypType=
+MeshDefaultkey=0
+MeshWEPKEY=
+MeshWPAKEY=
+MeshId=
+HSCounter=0
+HT_HTC=${HT_HTC}
+HT_RDG=1
+HT_LDPC=${ldpc:-1}
+HT_LinkAdapt=0
+HT_OpMode=${greenfield:-0}
+HT_MpduDensity=4
+HT_EXTCHA=${EXTCHA}
+HT_BW=${HT_BW:-0}
+HT_AutoBA=1
+HT_BADecline=0
+HT_AMSDU=1
+HT_BAWinSize=64
+HT_GI=${HT_GI:-1}
+HT_STBC=${tx_stbc:-1}
+HT_LDPC=${ldpc:-1}
+HT_MCS=33
+VHT_BW=${VHT_BW:-0}
+VHT_SGI=1
+VHT_STBC=${tx_stbc:-1}
+VHT_BW_SIGNAL=0
+VHT_DisallowNonVHT=${VHT_DisallowNonVHT:-0}
+VHT_LDPC=${ldpc:-1}
+#HT_TxStream=2
+#HT_RxStream=2
+HT_PROTECT=0
+HT_DisallowTKIP=${HT_DisallowTKIP:-0}
+HT_BSSCoexistence=${HT_CE:-1}
+HT_BSSCoexApCntThr=10
+GreenAP=${greenap:-0}
+WscConfMode=0
+WscConfStatus=1
+WCNTest=0
+RADIUS_Server=
+RADIUS_Port=1812
+RADIUS_Key1=
+RADIUS_Key2=
+RADIUS_Key3=
+RADIUS_Key4=
+RADIUS_Key5=
+RADIUS_Key6=
+RADIUS_Key7=
+RADIUS_Key8=
+RADIUS_Acct_Server=
+RADIUS_Acct_Port=1813
+RADIUS_Acct_Key=
+own_ip_addr=
+Ethifname=
+EAPifname=
+PreAuthifname=
+session_timeout_interval=0
+idle_timeout_interval=0
+WiFiTest=0
+TGnWifiTest=0
+ApCliEnable=0
+ApCliSsid=
+ApCliBssid=
+ApCliAuthMode=
+ApCliEncrypType=
+ApCliWPAPSK=
+ApCliDefaultKeyID=0
+ApCliKey1Type=0
+ApCliKey1Str=
+ApCliKey2Type=0
+ApCliKey2Str=
+ApCliKey3Type=0
+ApCliKey3Str=
+ApCliKey4Type=0
+ApCliKey4Str=
+RadioOn=1
+WscManufacturer=PandoraBox
+WscModelName=PandoraBox Wireless Router
+WscDeviceName=PandoraBox WiFi
+WscModelNumber=
+WscSerialNumber=
+PMFMFPC=0
+PMFMFPR=0
+PMFSHA256=0
+LoadCodeMethod=0
+AutoChannelSkipList=${ACSSKIP}
+MaxStaNum=${maxassoc:-0}
+WirelessEvent=1
+AuthFloodThreshold=64
+AssocReqFloodThreshold=64
+ReassocReqFloodThreshold=64
+ProbeReqFloodThreshold=64
+DisassocFloodThreshold=64
+DeauthFloodThreshold=64
+EapReqFloodThreshold=64
+Thermal=100
+EnhanceMultiClient=1
+IgmpSnEnable=0
+#DetectPhy=1
+BGMultiClient=1
+EDCCA=0
+HT_MIMOPSMode=3
+PandoraBoxSmart=${smart:-1}
+RED_Enable=1
+VOW_Airtime_Fairness_En=1
+CP_SUPPORT=2
+BandSteering=0
+BndStrgRssiDiff=15
+BndStrgRssiLow=-86
+BndStrgAge=600000
+BndStrgHoldTime=3000
+BndStrgCheckTime=6000
+SCSEnable=1
+DyncVgaEnable=1
+SkipLongRangeVga=0
+VgaClamp=0
+FastRoaming=0
+AutoRoaming=0
+FtSupport=0
+FtRic=1;1;1;1
+FtOtd=0;0;0;0
+FtMdId1=A1
+FtMdId2=A2
+FtMdId3=A3
+FtMdId4=A4
+FtR0khId1=4f577274
+FtR0khId2=4f577276
+FtR0khId3=4f577278
+FtR0khId4=4f57727A
+BandDeltaRssi=-12
+ApProbeRspTimes=3
+#AuthRspFail=0
+#AuthRspRssi=0
+#AssocReqRssiThres=-68
+#AssocRspIgnor=0
+#KickStaRssiLow=-75
+KickStaRssiLowPSM=-77
+#KickStaRssiLowDelay=6
+#ProbeRspRssi=-72
+VideoClassifierEnable=1
+VideoHighTxMode=1
+VideoTurbine=1
+VideoTxLifeTimeMode=1
+EOF
+
+#接口配置生成
+#	AP模式
+#	统一设置的内容:
+	ApEncrypType=""
+	ApAuthMode=""
+	ApBssidNum=0
+	ApHideESSID=""
+	ApDefKId=""
+	ApK1Tp=""
+	ApK2Tp=""
+	ApK3Tp=""
+	ApK4Tp=""
+
+	for_each_interface "ap" mt_dbdc_ap_vif_pre_config
+
+#For DBDC profile merging......
+	while [ $ApBssidNum -lt $RTWIFI_DEF_MAX_BSSID ]
+	do
+		ApEncrypType="${ApEncrypType}NONE;"
+		ApAuthMode="${ApAuthMode}OPEN;"
+		ApHideESSID="${ApHideESSID}0;"
+		ApDefKId="${ApDefKId}0;"
+		ApK1Tp="${ApK1Tp}0;"
+		ApK2Tp="${ApK2Tp}0;"
+		ApK3Tp="${ApK3Tp}0;"
+		ApK4Tp="${ApK4Tp}0;"
+		let ApBssidNum+=1
+	done
+
+	echo "AuthMode=${ApAuthMode%?}" >> $RTWIFI_PROFILE_PATH
+	echo "EncrypType=${ApEncrypType%?}" >> $RTWIFI_PROFILE_PATH
+	echo "HideSSID=${ApHideESSID%?}" >> $RTWIFI_PROFILE_PATH
+	echo "DefaultKeyID=${ApDefKId%?}" >> $RTWIFI_PROFILE_PATH
+	echo "Key1Type=${ApK1Tp%?}" >> $RTWIFI_PROFILE_PATH
+	echo "Key2Type=${ApK2Tp%?}" >> $RTWIFI_PROFILE_PATH
+	echo "Key3Type=${ApK3Tp%?}" >> $RTWIFI_PROFILE_PATH
+	echo "Key4Type=${ApK4Tp%?}" >> $RTWIFI_PROFILE_PATH
+
+#	WDS接口数目
+	WDSBssidNum=0
+	WDSEN=0
+	WDSList=""
+	WDSEncType=""
+	WDSDefKeyID=""
+	WDSPhyMode=""
+	WDSTxMCS=""
+	for_each_interface "wds" mt_dbdc_wds_vif_pre_config
+	echo "WdsEnable=${WDSEN%?}" >> $RTWIFI_PROFILE_PATH
+	echo "WdsList=${WDSList%?}" >> $RTWIFI_PROFILE_PATH
+	echo "WdsEncrypType=${WdsEncType%?}" >> $RTWIFI_PROFILE_PATH
+	echo "WdsDefaultKeyID=${WDSDefKeyID%?}" >> $RTWIFI_PROFILE_PATH
+	echo "WdsPhyMode=${WDSPhyMode%?}" >> $RTWIFI_PROFILE_PATH
+	echo "WdsTxMcs=${WDSTxMCS%?}" >> $RTWIFI_PROFILE_PATH
+
+#接口上线
+#加锁
+	echo "Pending..."
+	lock $WIFI_OP_LOCK
+	sleep 3
+	RA_MAIN_UP=$(get_if_stat ra0)
+	drv_mt_dbdc_teardown $phy_name
+	RESET_IF=$(mt_dbdc_vif_down $phy_name)
+	echo "MT_DBDC:ra0:$RA_MAIN_UP.Later we'll restart $(echo ${RESET_IF} | tr '\n' ' ')"
+	sleep 1
+
+#Start root device
+	[ "$phy_name" == "rax" ] && ifconfig ra0 up
+#restore interfaces
+	[ -z "$RESET_IF" ] || {
+		for i in $RESET_IF
+		do
+			ifconfig $i up
+		done
+		sh $RTWIFI_CMD_OPATH
+	}
+#AP模式
+	ApIfCNT=0
+	for_each_interface "ap" mt_dbdc_ap_vif_post_config
+#WDS接口
+	WDSBssidNum=0
+	for_each_interface "wds" mt_dbdc_wds_vif_post_config
+#STA模式
+	stacount=0
+	for_each_interface "sta" mt_dbdc_sta_vif_connect
+
+	[ "$phy_name" == "rax" ] && [ "$RA_MAIN_UP" == "down" ] && ifconfig ra0 down
+
+#重启HWNAT
+	[ -d /sys/module/hw_nat ] && {
+		/etc/init.d/hwacc restart
+	}
+#设置无线上线
+	wireless_set_up
+#解锁
+	lock -u $WIFI_OP_LOCK
+}
+add_driver mt_dbdc
diff --git a/package/feeds/custom/mt7615d/files/lib/wifi/mt_dbdc.sh b/package/feeds/custom/mt7615d/files/lib/wifi/mt_dbdc.sh
new file mode 100644
index 00000000000..1de506a19cf
--- /dev/null
+++ b/package/feeds/custom/mt7615d/files/lib/wifi/mt_dbdc.sh
@@ -0,0 +1,76 @@
+#!/bin/sh
+#
+# Copyright (c) 2014 OpenWrt
+# Copyright (C) 2013-2015 D-Team Technology Co.,Ltd. ShenZhen
+# Copyright (c) 2005-2015, lintel <lintel.huang@gmail.com>
+# Copyright (c) 2013, Hoowa <hoowa.sun@gmail.com>
+# Copyright (c) 2015-2017, GuoGuo <gch981213@gmail.com>
+#
+# 	Detect script for MT7615 DBDC mode
+#
+# 	嘿，对着屏幕的哥们,为了表示对原作者辛苦工作的尊重，任何引用跟借用都不允许你抹去所有作者的信息,请保留这段话。
+#
+
+append DRIVERS "mt_dbdc"
+
+. /lib/functions.sh
+. /lib/functions/system.sh
+
+mt_get_first_if_mac() {
+	local wlan_mac=""
+	factory_part=$(find_mtd_part factory)
+	dd bs=1 skip=4 count=6 if=$factory_part 2>/dev/null | /usr/sbin/maccalc bin2mac	
+}
+
+detect_mt_dbdc() {
+	local macaddr
+	[ -d /sys/module/mt_wifi ] && [ $( grep -c ra0 /proc/net/dev) -eq 1 ] && {
+		for phyname in ra rax; do
+		config_get type $phyname type
+		macaddr=$(mt_get_first_if_mac)
+		[ "$type" == "mt_dbdc" ] || {
+			case $phyname in
+				ra)
+					hwmode=11g
+					htmode=HT20
+					pb_smart=1
+					noscan=0
+					ssid="OpenWRT-2.4G-$(echo $macaddr | awk -F ":" '{print $4""$5""$6 }'| tr a-z A-Z)"
+					;;
+				rax)
+					hwmode=11a
+					htmode=VHT80
+					macaddr=$(mt_get_first_if_mac)
+					ssid="OpenWRT-5G-$(maccalc add $macaddr 3145728 | awk -F ":" '{print $4""$5""$6 }'| tr a-z A-Z)"
+					pb_smart=0
+					noscan=1
+					;;
+			esac
+			
+#		[ -n "$macaddr" ] && {
+#			dev_id="set wireless.${phyname}.macaddr=${macaddr}"
+#		}
+		uci -q batch <<-EOF
+			set wireless.${phyname}=wifi-device
+			set wireless.${phyname}.type=mt_dbdc
+			set wireless.${phyname}.hwmode=$hwmode
+			set wireless.${phyname}.channel=auto
+			set wireless.${phyname}.txpower=100
+			set wireless.${phyname}.htmode=$htmode
+			set wireless.${phyname}.country=CN
+			set wireless.${phyname}.txburst=1
+			set wireless.${phyname}.noscan=$noscan
+			set wireless.${phyname}.smart=$pb_smart
+
+			set wireless.default_${phyname}=wifi-iface
+			set wireless.default_${phyname}.device=${phyname}
+			set wireless.default_${phyname}.network=lan
+			set wireless.default_${phyname}.mode=ap
+			set wireless.default_${phyname}.ssid=${ssid}
+			set wireless.default_${phyname}.encryption=none
+EOF
+		uci -q commit wireless
+		}
+		done
+	}
+}
diff --git a/package/feeds/custom/mt7615d/src/mt_wifi/embedded/common/cmm_info.c b/package/feeds/custom/mt7615d/src/mt_wifi/embedded/common/cmm_info.c
index cbae8ba9b45..74ea4dc9633 100644
--- a/package/feeds/custom/mt7615d/src/mt_wifi/embedded/common/cmm_info.c
+++ b/package/feeds/custom/mt7615d/src/mt_wifi/embedded/common/cmm_info.c
@@ -4948,7 +4948,7 @@ VOID RTMPIoctlGetMacTableStaInfo(
 	IN RTMP_IOCTL_INPUT_STRUCT *wrq)
 {
 	INT i;
-	BOOLEAN need_send = FALSE;
+	BOOLEAN need_send;
 	RT_802_11_MAC_TABLE *pMacTab = NULL;
 	PRT_802_11_MAC_ENTRY pDst;
 	MAC_TABLE_ENTRY *pEntry;
@@ -4965,12 +4965,11 @@ VOID RTMPIoctlGetMacTableStaInfo(
 	for (i = 0; VALID_UCAST_ENTRY_WCID(pAd, i); i++) {
 		pEntry = &(pAd->MacTab.Content[i]);
 
+		need_send = FALSE;
 		if (pEntry->wdev != NULL) {
 			/* As per new GUI design ifname with index as ra0/ra1/rai0/rai1/... (may not work with older GUI)*/
 			if (!strcmp(wrq->ifr_ifrn.ifrn_name, pEntry->wdev->if_dev->name))
 				need_send = TRUE;
-			else
-				need_send = FALSE;
 		}
 		if (IS_ENTRY_CLIENT(pEntry) && (pEntry->Sst == SST_ASSOC) && (need_send == TRUE)) {
 			pDst = &pMacTab->Entry[pMacTab->Num];
diff --git a/package/feeds/custom/mt7615d/src/mt_wifi/embedded/common/multi_profile.c b/package/feeds/custom/mt7615d/src/mt_wifi/embedded/common/multi_profile.c
index 941251dac79..9cb5526642c 100644
--- a/package/feeds/custom/mt7615d/src/mt_wifi/embedded/common/multi_profile.c
+++ b/package/feeds/custom/mt7615d/src/mt_wifi/embedded/common/multi_profile.c
@@ -18,9 +18,9 @@
 #include "rt_config.h"
 
 /*Local definition*/
-#define FIRST_AP_2G_PROFILE_PATH	"/etc/Wireless/RT2860/RT2860_2G.dat"
-#define FIRST_AP_5G_PROFILE_PATH	"/etc/Wireless/RT2860/RT2860_5G.dat"
-#define FIRST_AP_MERGE_PROFILE_PATH ""
+#define FIRST_AP_2G_PROFILE_PATH	"/tmp/profiles/mt_dbdc_2g.dat"
+#define FIRST_AP_5G_PROFILE_PATH	"/tmp/profiles/mt_dbdc_5g.dat"
+#define FIRST_AP_MERGE_PROFILE_PATH "/tmp/profiles/mt_dbdc.dat"
 #if defined(BB_SOC) && !defined(MULTI_INF_SUPPORT)
 #define FIRST_AP_5G_DEVNAME "rai0"
 #define FIRST_MBSSID_5G_DEVNAME "rai"
diff --git a/package/feeds/custom/mt7615d/src/mt_wifi/embedded/include/cfg80211extr.h b/package/feeds/custom/mt7615d/src/mt_wifi/embedded/include/cfg80211extr.h
index 86b954cd7d1..b1b643b6be2 100644
--- a/package/feeds/custom/mt7615d/src/mt_wifi/embedded/include/cfg80211extr.h
+++ b/package/feeds/custom/mt7615d/src/mt_wifi/embedded/include/cfg80211extr.h
@@ -70,6 +70,10 @@ CFG80211_Scaning((VOID *)__pAd, __BssIdx, __ChanId, __pFrame,			\
 #define RT_CFG80211_LOST_AP_INFORM(__pAd)									\
 	CFG80211_LostApInform((VOID *)__pAd);
 #endif /*CONFIG_STA_SUPPORT || APCLI_CFG80211_SUPPORT */
+#ifdef RT_CFG80211_P2P_CONCURRENT_DEVICE
+#define RT_CFG80211_LOST_GO_INFORM(__pAd) 									\
+	CFG80211_LostP2pGoInform((VOID *)__pAd);
+#endif /*RT_CFG80211_P2P_CONCURRENT_DEVICE*/
 #define RT_CFG80211_REINIT(__pAd, __wdev)											\
 	CFG80211_SupBandReInit((VOID *)__pAd, (VOID *)__wdev);
 
@@ -188,6 +192,7 @@ VOID CFG80211_ConnectResultInform(
 	UCHAR *pRspIe, UINT32 RspIeLen,	UCHAR FlgIsSuccess);
 VOID CFG80211DRV_PmkidConfig(VOID *pAdOrg, VOID *pData);
 VOID CFG80211_LostApInform(VOID *pAdCB);
+VOID CFG80211_LostP2pGoInform(VOID *pAdCB);
 
 INT CFG80211_StaPortSecured(
 	VOID                         *pAdCB,
diff --git a/package/feeds/custom/mt7615d/src/mt_wifi/embedded/include/l1profile.h b/package/feeds/custom/mt7615d/src/mt_wifi/embedded/include/l1profile.h
index 998ffc3690e..ee352ab23c7 100644
--- a/package/feeds/custom/mt7615d/src/mt_wifi/embedded/include/l1profile.h
+++ b/package/feeds/custom/mt7615d/src/mt_wifi/embedded/include/l1profile.h
@@ -1,8 +1,7 @@
-#ifdef DEFAULT_5G_PROFILE
 UCHAR l1profile_default[] = {
 "Default\n\
 INDEX0=MT7615\n\
-INDEX0_profile_path=/etc/Wireless/RT2860/RT2860_2G.dat;/etc/Wireless/RT2860/RT2860_5G.dat\n\
+INDEX0_profile_path=/tmp/profiles/mt_dbdc_2g.dat;/tmp/profiles/mt_dbdc_5g.dat\n\
 INDEX0_EEPROM_offset=0x0\n\
 INDEX0_EEPROM_size=0x4000\n\
 INDEX0_EEPROM_name=e2p\n\
@@ -28,61 +27,3 @@ INDEX1_nvram_zone=RTDEV\n\
 INDEX1_single_sku_path=/etc_ro/Wireless/RT2860AP/SingleSKU.dat\n\
 INDEX1_bf_sku_path=/etc_ro/Wireless/RT2860AP/SingleSKU_BF.dat\n"
 };
-
-#else
-UCHAR l1profile_default[] = {
-"Default\n\
-INDEX0=MT7615\n\
-INDEX0_profile_path=/etc/Wireless/RT2860/RT2860.dat\n\
-INDEX0_EEPROM_offset=0x0\n\
-INDEX0_EEPROM_size=0x4000\n\
-INDEX0_EEPROM_name=e2p\n\
-INDEX0_main_ifname=ra0\n\
-INDEX0_ext_ifname=ra\n\
-INDEX0_wds_ifname=wds\n\
-INDEX0_apcli_ifname=apcli\n\
-INDEX0_mesh_ifname=mesh\n\
-INDEX0_nvram_zone=RT2860\n\
-INDEX0_single_sku_path=/etc_ro/Wireless/RT2860AP/SingleSKU.dat\n\
-INDEX0_bf_sku_path=/etc_ro/Wireless/RT2860AP/SingleSKU_BF.dat\n\
-INDEX1=MT7615\n\
-INDEX1_profile_path=/etc/Wireless/iNIC/iNIC_ap.dat\n\
-INDEX1_EEPROM_offset=0x8000\n\
-INDEX1_EEPROM_size=0x4000\n\
-INDEX1_EEPROM_name=e2p\n\
-INDEX1_main_ifname=rai0\n\
-INDEX1_ext_ifname=rai\n\
-INDEX1_wds_ifname=wdsi\n\
-INDEX1_apcli_ifname=apclii\n\
-INDEX1_mesh_ifname=meshi\n\
-INDEX1_nvram_zone=RTDEV\n\
-INDEX1_single_sku_path=/etc_ro/Wireless/RT2860AP/SingleSKU.dat\n\
-INDEX1_bf_sku_path=/etc_ro/Wireless/RT2860AP/SingleSKU_BF.dat\n\
-INDEX2=MT7615\n\
-INDEX2_profile_path=/etc/Wireless/WIFI3/RT2870AP.dat\n\
-INDEX2_EEPROM_offset=0x4000\n\
-INDEX2_EEPROM_size=0x4000\n\
-INDEX2_EEPROM_name=e2p\n\
-INDEX2_main_ifname=rae0\n\
-INDEX2_ext_ifname=rae\n\
-INDEX2_wds_ifname=wdsex\n\
-INDEX2_apcli_ifname=apclie\n\
-INDEX2_mesh_ifname=meshe\n\
-INDEX2_nvram_zone=WIFI3\n\
-INDEX2_single_sku_path=/etc_ro/Wireless/RT2860AP/SingleSKU.dat\n\
-INDEX2_bf_sku_path=/etc_ro/Wireless/RT2860AP/SingleSKU_BF.dat\n\
-INDEX3=MT7615A\n\
-INDEX3_profile_path=/etc/Wireless/MT7615A_B0_5G.dat;/etc/Wireless/MT7615A_B1_5G.dat\n\
-INDEX3_EEPROM_offset=0x0\n\
-INDEX3_EEPROM_size=0x4000\n\
-INDEX3_EEPROM_name=e2p\n\
-INDEX3_main_ifname=ra0;rax0\n\
-INDEX3_ext_ifname=ra;rax\n\
-INDEX3_wds_ifname=wds;wdsx\n\
-INDEX3_apcli_ifname=apcli;apclix\n\
-INDEX3_mesh_ifname=mesh;meshx\n\
-INDEX3_nvram_zone=RT2860\n\
-INDEX3_single_sku_path=/etc_ro/Wireless/RT2860AP/SingleSKU.dat\n\
-INDEX3_bf_sku_path=/etc_ro/Wireless/RT2860AP/SingleSKU_BF.dat\n"
-};
-#endif
diff --git a/package/feeds/custom/mt7615d/src/mt_wifi/embedded/include/rtmp.h b/package/feeds/custom/mt7615d/src/mt_wifi/embedded/include/rtmp.h
index 9025f222124..ab0bd6dc0d9 100644
--- a/package/feeds/custom/mt7615d/src/mt_wifi/embedded/include/rtmp.h
+++ b/package/feeds/custom/mt7615d/src/mt_wifi/embedded/include/rtmp.h
@@ -5288,6 +5288,7 @@ typedef struct _CFG80211_CONTROL {
 	/* MainDevice Info. */
 	CFG80211_VIF_DEV cfg80211MainDev;
 #if defined(RT_CFG80211_P2P_CONCURRENT_DEVICE) || defined(CFG80211_MULTI_STA)
+	BOOLEAN bP2pCliPmEnable;
 	/* For add_virtual_intf */
 	CFG80211_VIF_DEV_SET Cfg80211VifDevSet;
 #endif /* RT_CFG80211_P2P_CONCURRENT_DEVICE || CFG80211_MULTI_STA */
diff --git a/package/feeds/custom/mt7615d/src/mt_wifi/embedded/include/rtmp_comm.h b/package/feeds/custom/mt7615d/src/mt_wifi/embedded/include/rtmp_comm.h
index c70bd2cc652..6f317da23bb 100644
--- a/package/feeds/custom/mt7615d/src/mt_wifi/embedded/include/rtmp_comm.h
+++ b/package/feeds/custom/mt7615d/src/mt_wifi/embedded/include/rtmp_comm.h
@@ -437,6 +437,6 @@ typedef struct  _PACKET_INFO    {
 extern VOID *adapt_list[MAX_NUM_OF_INF];
 #endif /* MULTI_INF_SUPPORT */
 #ifdef CREATE_ALL_INTERFACE_AT_INIT
-#define MAX_MBSS_NUM 8	
+#define MAX_MBSS_NUM 4
 #endif
 #endif /* __RT_COMM_H__ */
diff --git a/package/feeds/custom/mt7615d/src/mt_wifi/os/linux/ap_ioctl.c b/package/feeds/custom/mt7615d/src/mt_wifi/os/linux/ap_ioctl.c
index 6d128ee8f51..71b3a3d4aa0 100644
--- a/package/feeds/custom/mt7615d/src/mt_wifi/os/linux/ap_ioctl.c
+++ b/package/feeds/custom/mt7615d/src/mt_wifi/os/linux/ap_ioctl.c
@@ -32,6 +32,22 @@
 #include <linux/wireless.h>
 #include "rtmp_def.h"
 
+static const UCHAR Cfg80211_Chan[] = {
+	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, //14
+
+	/* 802.11 UNI / HyperLan 2 */
+	36, 40, 44, 48, 52, 56, 60, 64, //8
+
+	/* 802.11 HyperLan 2 */
+	100, 104, 108, 112, 116, 120, 124, 128, 132, 136, //10
+
+	/* 802.11 UNII */
+	140, 144, 149, 153, 157, 161, 165, 169, 173, //9
+
+	/* Japan */
+	184, 188, 192, 196, 208, 212, 216, //7
+};
+
 struct iw_priv_args ap_privtab[] = {
 	{
 		RTPRIV_IOCTL_SET,
@@ -131,6 +147,44 @@ const struct iw_handler_def rt28xx_ap_iw_handler_def = {
 };
 #endif /* CONFIG_APSTA_MIXED_SUPPORT */
 
+static int rtw_ch2freq(int chan)
+{
+	/* see 802.11 17.3.8.3.2 and Annex J
+	* there are overlapping channel numbers in 5GHz and 2GHz bands */
+
+	/*
+	* RTK: don't consider the overlapping channel numbers: 5G channel <= 14,
+	* because we don't support it. simply judge from channel number
+	*/
+
+	if (chan >= 1 && chan <= 14) {
+		if (chan == 14)
+			return 2484;
+		else if (chan < 14)
+			return 2407 + chan * 5;
+	} else if (chan >= 36 && chan <= 177)
+		return 5000 + chan * 5;
+
+	return 0; /* not supported */
+}
+
+static void setChans(struct iw_range *prange) {
+	/* channels */
+	int i;
+	int NumOfChan = CFG80211_NUM_OF_CHAN_2GHZ + CFG80211_NUM_OF_CHAN_5GHZ;
+	if (NumOfChan > 32) {
+		// iw_range::freq cannot exceed 32 items 
+		NumOfChan = 32;
+	}
+	for (i = 0; i < NumOfChan; i++) {
+		prange->freq[i].i = Cfg80211_Chan[i];
+		prange->freq[i].e = 6;
+		prange->freq[i].m = rtw_ch2freq(Cfg80211_Chan[i]);
+	}
+	prange->num_channels = NumOfChan;
+	prange->num_frequency = NumOfChan;
+
+}
 
 INT rt28xx_ap_ioctl(struct net_device *net_dev, struct ifreq *rq, int cmd)
 {
@@ -285,9 +339,9 @@ INT rt28xx_ap_ioctl(struct net_device *net_dev, struct ifreq *rq, int cmd)
 		ULONG Channel;
 
 		RTMP_DRIVER_CHANNEL_GET(pAd, pIoctlConfig->apidx, &Channel);
-		wrqin->u.freq.m = Channel; /*wdev->channel; */
-		wrqin->u.freq.e = 0;
-		wrqin->u.freq.i = 0;
+		wrqin->u.freq.m = rtw_ch2freq(Channel); /*wdev->channel; */
+		wrqin->u.freq.e = 6;
+		wrqin->u.freq.i = Channel;
 	}
 	break;
 
@@ -365,7 +419,17 @@ INT rt28xx_ap_ioctl(struct net_device *net_dev, struct ifreq *rq, int cmd)
 
 		memset(prange, 0, sizeof(struct iw_range));
 		prange->we_version_compiled = WIRELESS_EXT;
-		prange->we_version_source = 14;
+		prange->we_version_source = 16;
+		prange->retry_capa = IW_RETRY_LIMIT;
+		prange->retry_flags = IW_RETRY_LIMIT;
+		prange->min_retry = 0;
+		prange->max_retry = 255;
+		prange->min_rts = 0;
+		prange->max_rts = 2347;
+		prange->min_frag = 256;
+		prange->max_frag = 2346;
+
+		prange->max_encoding_tokens = 4;
 		/*
 		 *	what is correct max? This was not
 		 *	documented exactly. At least
@@ -374,6 +438,16 @@ INT rt28xx_ap_ioctl(struct net_device *net_dev, struct ifreq *rq, int cmd)
 		prange->max_qual.qual = 100;
 		prange->max_qual.level = 0; /* dB */
 		prange->max_qual.noise = 0; /* dB */
+
+		/* channels */
+		setChans(prange);
+
+		/* encrypt */
+		prange->enc_capa |= (IW_ENC_CAPA_CIPHER_TKIP |
+					IW_ENC_CAPA_WPA |
+					IW_ENC_CAPA_CIPHER_CCMP |
+					IW_ENC_CAPA_WPA2);
+
 		len = copy_to_user(wrq->u.data.pointer, prange, sizeof(struct iw_range));
 		os_free_mem(prange);
 	}
diff --git a/package/feeds/custom/mt7615d/src/mt_wifi/os/linux/cfg80211/cfg80211.c b/package/feeds/custom/mt7615d/src/mt_wifi/os/linux/cfg80211/cfg80211.c
index 203642812e8..52da0ae8937 100644
--- a/package/feeds/custom/mt7615d/src/mt_wifi/os/linux/cfg80211/cfg80211.c
+++ b/package/feeds/custom/mt7615d/src/mt_wifi/os/linux/cfg80211/cfg80211.c
@@ -1687,6 +1687,30 @@ static void CFG80211_OpsMgmtFrameRegister(
 		CFG80211DBG(DBG_LVL_ERROR, ("Unkown frame_type = %x, req = %d\n", frame_type, reg));
 }
 
+#ifdef CPTCFG_BACKPORTED_CFG80211_MODULE
+static void CFG80211_OpsUpdateMgmtFrameRegistrations(
+	struct wiphy *pWiphy,
+	struct wireless_dev *wdev,
+	struct mgmt_frame_regs *upd)
+{
+	VOID *pAd;
+	struct net_device *dev = NULL;
+	u32 preq_mask = BIT(IEEE80211_STYPE_PROBE_REQ >> 4);
+	u32 action_mask = BIT(IEEE80211_STYPE_ACTION >> 4);
+	MAC80211_PAD_GET_NO_RV(pAd, pWiphy);
+	RTMP_DRIVER_NET_DEV_GET(pAd, &dev);
+
+	CFG80211DBG(DBG_LVL_INFO, ("80211> %s ==>\n", __func__));
+	CFG80211DBG(DBG_LVL_INFO, ("IEEE80211_STYPE_PROBE_REQ = %x, IEEE80211_STYPE_ACTION = %d , (%d)\n", 
+		!!(upd->interface_stypes & preq_mask), !!(upd->interface_mcast_stypes & action_mask),  
+		dev->ieee80211_ptr->iftype));
+
+	RTMP_DRIVER_80211_MGMT_FRAME_REG(pAd, dev, !!(upd->interface_stypes & preq_mask));
+
+	RTMP_DRIVER_80211_ACTION_FRAME_REG(pAd, dev, !!(upd->interface_mcast_stypes & action_mask));
+}
+#endif
+
 /* Supplicant_NEW_TDLS */
 #ifdef CFG_TDLS_SUPPORT
 static int CFG80211_OpsTdlsMgmt
@@ -2568,10 +2592,15 @@ struct cfg80211_ops CFG80211_Ops = {
 	.set_cqm_rssi_config		= NULL,
 #endif /* LINUX_VERSION_CODE */
 
+#ifdef CPTCFG_BACKPORTED_CFG80211_MODULE
+	.update_mgmt_frame_registrations =
+		CFG80211_OpsUpdateMgmtFrameRegistrations,
+#else
 #if (KERNEL_VERSION(2, 6, 37) <= LINUX_VERSION_CODE)
 	/* notify driver that a management frame type was registered */
 	.mgmt_frame_register		= CFG80211_OpsMgmtFrameRegister,
 #endif /* LINUX_VERSION_CODE : 2.6.37 */
+#endif /* CPTCFG_BACKPORTED_CFG80211_MODULE */
 
 #if (KERNEL_VERSION(2, 6, 38) <= LINUX_VERSION_CODE)
 	/* set antenna configuration (tx_ant, rx_ant) on the device */
diff --git a/package/feeds/custom/mt7615d/src/mt_wifi/os/linux/cfg80211/cfg80211_p2p.c b/package/feeds/custom/mt7615d/src/mt_wifi/os/linux/cfg80211/cfg80211_p2p.c
index 09c30759b5e..e37238fcc41 100644
--- a/package/feeds/custom/mt7615d/src/mt_wifi/os/linux/cfg80211/cfg80211_p2p.c
+++ b/package/feeds/custom/mt7615d/src/mt_wifi/os/linux/cfg80211/cfg80211_p2p.c
@@ -13,14 +13,1259 @@
  ***************************************************************************/
 
 /****************************************************************************
- *
- *	Abstract:
- *
- *	All related CFG80211 P2P function body.
- *
- *	History:
- *
- ***************************************************************************/
+ 
+	Abstract:
+
+	All related CFG80211 P2P function body.
+
+	History:
+
+***************************************************************************/
+
 #define RTMP_MODULE_OS
 
+#ifdef RT_CFG80211_SUPPORT
+
+#include "rt_config.h"
+
+UCHAR CFG_WPS_OUI[4] = {0x00, 0x50, 0xf2, 0x04};
+UCHAR CFG_P2POUIBYTE[4] = {0x50, 0x6f, 0x9a, 0x9}; /* spec. 1.14 OUI */
+
+BUILD_TIMER_FUNCTION(CFG80211RemainOnChannelTimeout);
+
+static 
+VOID CFG80211_RemainOnChannelInit(RTMP_ADAPTER	 *pAd)
+{
+	if (pAd->cfg80211_ctrl.Cfg80211RocTimerInit == FALSE)
+	{
+		CFG80211DBG(RT_DEBUG_TRACE, ("CFG80211_ROC : INIT Cfg80211RocTimer\n"));
+		RTMPInitTimer(pAd, &pAd->cfg80211_ctrl.Cfg80211RocTimer, 
+			GET_TIMER_FUNCTION(CFG80211RemainOnChannelTimeout), pAd, FALSE);
+		pAd->cfg80211_ctrl.Cfg80211RocTimerInit = TRUE;
+	}
+}
+
+VOID CFG80211RemainOnChannelTimeout(
+	PVOID SystemSpecific1, PVOID FunctionContext,
+	PVOID SystemSpecific2, PVOID SystemSpecific3)
+{
+	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *) FunctionContext;
+	PCFG80211_CTRL pCfg80211_ctrl = &pAd->cfg80211_ctrl;
+
+	DBGPRINT(RT_DEBUG_INFO, ("CFG80211_ROC: RemainOnChannelTimeout\n"));
+	
+#ifdef RT_CFG80211_P2P_CONCURRENT_DEVICE
+#define RESTORE_COM_CH_TIME 100
+	APCLI_STRUCT *pApCliEntry = &pAd->ApCfg.ApCliTab[MAIN_MBSSID];
+
+	if (pApCliEntry->Valid && 
+	     	RTMP_CFG80211_VIF_P2P_CLI_ON(pAd) && 
+            	(pAd->LatchRfRegs.Channel != pApCliEntry->MlmeAux.Channel))
+	{
+		/* Extend the ROC_TIME for Common Channel When P2P_CLI on */
+		DBGPRINT(RT_DEBUG_TRACE, ("CFG80211_ROC: ROC_Timeout APCLI_ON Channel: %d\n", 
+								pApCliEntry->MlmeAux.Channel));
+
+        	AsicSwitchChannel(pAd, pApCliEntry->MlmeAux.Channel, FALSE);
+        	AsicLockChannel(pAd, pApCliEntry->MlmeAux.Channel);
+
+		DBGPRINT(RT_DEBUG_TRACE, ("CFG80211_NULL: P2P_CLI PWR_ACTIVE ROC_END\n"));
+		CFG80211_P2pClientSendNullFrame(pAd, PWR_ACTIVE);
+#ifdef CONFIG_STA_SUPPORT
+		if (INFRA_ON(pAd))
+		{
+			DBGPRINT(RT_DEBUG_TRACE, ("CFG80211_NULL: CONCURRENT STA PWR_ACTIVE ROC_END\n"));
+			RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, 
+					  (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED) ? TRUE:FALSE),
+					  pAd->CommonCfg.bAPSDForcePowerSave ? PWR_SAVE : pAd->StaCfg.Psm);			
+		}
+#endif /*CONFIG_STA_SUPPORT*/
+		RTMPSetTimer(&pCfg80211_ctrl->Cfg80211RocTimer, RESTORE_COM_CH_TIME);
+	}
+	else if (INFRA_ON(pAd) &&
+	   	     (pAd->LatchRfRegs.Channel != pAd->CommonCfg.Channel))
+	{
+		DBGPRINT(RT_DEBUG_TRACE, ("CFG80211_ROC: ROC_Timeout INFRA_ON Channel: %d\n", 
+									pAd->CommonCfg.Channel));
+
+        	AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
+        	AsicLockChannel(pAd, pAd->CommonCfg.Channel);
+#ifdef CONFIG_STA_SUPPORT
+		DBGPRINT(RT_DEBUG_TRACE, ("CFG80211_NULL: INFRA_ON PWR_ACTIVE ROC_END\n"));
+		RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, 
+				  (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED) ? TRUE:FALSE),
+				  pAd->CommonCfg.bAPSDForcePowerSave ? PWR_SAVE : pAd->StaCfg.Psm);
+#endif /*CONFIG_STA_SUPPORT*/		
+		RTMPSetTimer(&pCfg80211_ctrl->Cfg80211RocTimer, RESTORE_COM_CH_TIME);		    	 
+	}
+	else
+#endif /*RT_CFG80211_P2P_CONCURRENT_DEVICE */		
+	{
+/* CFG TODO: move to cfg802_util */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+		PWIRELESS_DEV pwdev = NULL;
+		pwdev = pCfg80211_ctrl->Cfg80211ChanInfo.pWdev;
+		cfg80211_remain_on_channel_expired(pwdev, pCfg80211_ctrl->Cfg80211ChanInfo.cookie,
+            		pCfg80211_ctrl->Cfg80211ChanInfo.chan, GFP_ATOMIC);
+#else
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+		cfg80211_remain_on_channel_expired( CFG80211_GetEventDevice(pAd),	
+			pCfg80211_ctrl->Cfg80211ChanInfo.cookie, pCfg80211_ctrl->Cfg80211ChanInfo.chan, 
+        		pCfg80211_ctrl->Cfg80211ChanInfo.ChanType, GFP_ATOMIC);
+#endif /* LINUX_VERSION_CODE 2.6.34 */
+#endif /* LINUX_VERSION_CODE 3.8.0 */
+
+		pCfg80211_ctrl->Cfg80211RocTimerRunning = FALSE;
+		DBGPRINT(RT_DEBUG_TRACE, ("CFG80211_ROC: RemainOnChannelTimeout -- FINISH\n"));
+	}		
+}
+
+/* Set a given time on specific channel to listen action Frame */
+BOOLEAN CFG80211DRV_OpsRemainOnChannel(VOID *pAdOrg, VOID *pData, UINT32 duration)
+{
+	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER)pAdOrg;
+	CMD_RTPRIV_IOCTL_80211_CHAN *pChanInfo;
+	BOOLEAN Cancelled;
+	PCFG80211_CTRL pCfg80211_ctrl = &pAd->cfg80211_ctrl;
+	UCHAR lock_channel;
+
+	pChanInfo = (CMD_RTPRIV_IOCTL_80211_CHAN *) pData;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+        PWIRELESS_DEV pwdev = NULL;
+        pwdev = pChanInfo->pWdev;
+#endif /* LINUX_VERSION_CODE: 3.6.0 */
+	
+	CFG80211DBG(RT_DEBUG_INFO, ("%s\n", __FUNCTION__));
+	
+#ifdef RT_CFG80211_P2P_CONCURRENT_DEVICE
+	APCLI_STRUCT *pApCliEntry = &pAd->ApCfg.ApCliTab[MAIN_MBSSID];
+	/* Will be Exit the ApCli Connected Channel so send Null frame on current */
+	if (pApCliEntry->Valid && 
+	    RTMP_CFG80211_VIF_P2P_CLI_ON(pAd) &&
+	        (pApCliEntry->MlmeAux.Channel != pChanInfo->ChanId) &&
+                (pApCliEntry->MlmeAux.Channel == pAd->LatchRfRegs.Channel))	
+	{
+        	DBGPRINT(RT_DEBUG_TRACE, ("CFG80211_NULL: APCLI PWR_SAVE ROC_START\n"));
+        	CFG80211_P2pClientSendNullFrame(pAd, PWR_SAVE);
+	}
+
+	if (INFRA_ON(pAd) &&
+	       (pAd->CommonCfg.Channel != pChanInfo->ChanId) &&
+               (pAd->CommonCfg.Channel == pAd->LatchRfRegs.Channel))	
+	{
+    		DBGPRINT(RT_DEBUG_TRACE, ("CFG80211_NULL: STA PWR_SAVE ROC_START\n"));
+		RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, 
+				  (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED) ? TRUE:FALSE),
+				  PWR_SAVE);				
+	}	
+#endif /*RT_CFG80211_P2P_CONCURRENT_DEVICE */
+
+	/* Channel Switch Case:
+	 * 1. P2P_FIND:    [SOCIAL_CH]->[COM_CH]->[ROC_CH]--N_TUs->[ROC_TIMEOUT]
+	 *                 Set COM_CH to ROC_CH for merge COM_CH & ROC_CH dwell section.
+     	 *	 
+	 * 2. OFF_CH_WAIT: [ROC_CH]--200ms-->[ROC_TIMEOUT]->[COM_CH]
+	 *                 Most in GO case.
+	 * 
+	 */
+	//lock_channel = CFG80211_getCenCh(pAd, pChanInfo->ChanId);
+	lock_channel = pChanInfo->ChanId;
+	if (pAd->LatchRfRegs.Channel != lock_channel
+#ifdef CONFIG_STA_SUPPORT
+	|| (INFRA_ON(pAd) && (pAd->CommonCfg.BBPCurrentBW == BW_40))
+#endif /* CONFIG_STA_SUPPORT */
+	) 
+	{
+		DBGPRINT(RT_DEBUG_TRACE, ("CFG80211_PKT: ROC CHANNEL_LOCK %d\n", pChanInfo->ChanId));
+		//AsicSetChannel(pAd, lock_channel, BW_20, EXTCHA_NONE, FALSE);
+		bbp_set_bw(pAd, BW_20);
+		AsicSwitchChannel(pAd, lock_channel, FALSE);
+		AsicLockChannel(pAd, lock_channel);	
+	}
+	else
+	{
+		DBGPRINT(RT_DEBUG_INFO, ("80211> ComCH == ROC_CH \n"));
+	}
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+        cfg80211_ready_on_channel(pwdev,  pChanInfo->cookie, pChanInfo->chan, duration, GFP_ATOMIC);	
+#else
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+	cfg80211_ready_on_channel(CFG80211_GetEventDevice(pAd), pChanInfo->cookie, 
+				  pChanInfo->chan, pChanInfo->ChanType, duration, GFP_ATOMIC);
+#endif /* LINUX_VERSION_CODE: 2.6.34 */
+#endif /* LINUX_VERSION_CODE: 3.6.0 */
+
+	NdisCopyMemory(&pCfg80211_ctrl->Cfg80211ChanInfo, pChanInfo, sizeof(CMD_RTPRIV_IOCTL_80211_CHAN));
+
+	CFG80211_RemainOnChannelInit(pAd);
+	
+	if (pCfg80211_ctrl->Cfg80211RocTimerRunning == TRUE)
+	{
+		DBGPRINT(RT_DEBUG_TRACE, ("CFG80211_ROC : CANCEL Cfg80211RocTimer\n"));
+		RTMPCancelTimer(&pCfg80211_ctrl->Cfg80211RocTimer, &Cancelled);
+		pCfg80211_ctrl->Cfg80211RocTimerRunning = FALSE;
+	}
+
+	RTMPSetTimer(&pCfg80211_ctrl->Cfg80211RocTimer, duration + 20);
+	pCfg80211_ctrl->Cfg80211RocTimerRunning = TRUE;
+
+	return TRUE;	
+}
+
+BOOLEAN CFG80211DRV_OpsCancelRemainOnChannel(VOID *pAdOrg, UINT32 cookie)
+{
+	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER)pAdOrg;
+	BOOLEAN Cancelled;
+	CFG80211DBG(RT_DEBUG_TRACE, ("%s\n", __FUNCTION__));
+
+	if (pAd->cfg80211_ctrl.Cfg80211RocTimerRunning == TRUE)
+	{
+		DBGPRINT(RT_DEBUG_TRACE, ("CFG_ROC : CANCEL Cfg80211RocTimer\n"));
+		RTMPCancelTimer(&pAd->cfg80211_ctrl.Cfg80211RocTimer, &Cancelled);
+		pAd->cfg80211_ctrl.Cfg80211RocTimerRunning = FALSE;
+	}
+}
+
+INT CFG80211_setPowerMgmt(VOID *pAdCB, UINT Enable)
+{
+	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER)pAdCB;
+
+	DBGPRINT(RT_DEBUG_TRACE, ("@@@ %s: %d\n", __FUNCTION__, Enable));
+
+#ifdef RT_CFG80211_P2P_SUPPORT		
+	pAd->cfg80211_ctrl.bP2pCliPmEnable = Enable;
+#endif /* RT_CFG80211_P2P_SUPPORT */
+
+	return 0;	
+}
+
+#ifdef RT_CFG80211_P2P_SUPPORT
+/*	
+	==========================================================================
+	Description: 
+		Make a P2P Fake NoA Attribute to trigger myself to restart NoA. 
+		The Start time is changed. Duration and Interval and Count is 
+		the same as GO's beacon
+		
+	Parameters: 
+		 StartTime : A new Start time.
+		 pOutBuffer : pointer to buffer that should put data to.
+	Note:
+		 
+	==========================================================================
+ */
+VOID CFG80211_P2PMakeFakeNoATlv(PRTMP_ADAPTER pAd, ULONG StartTime, PUCHAR pOutBuffer)
+{
+	PUCHAR	pDest;
+	PP2PCLIENT_NOA_SCHEDULE pNoa = &pAd->cfg80211_ctrl.GONoASchedule;
+	pDest = pOutBuffer;
+
+	*(pDest) = SUBID_P2P_NOA;
+	/* Length is 13*n + 2 = 15 when n = 1 */
+	*(pDest+1) = 15;
+	/* Lenght 2nd byte */
+	*(pDest+2) = 0;
+	/* Index. */
+	*(pDest+3) = pNoa->Token;
+	/* CT Windows and OppPS parm. Don't turn on both. So Set CTWindows = 0 */
+	*(pDest+4) = 0;
+	/* Count.  Test Plan set to 255. */
+	*(pDest+5) = pNoa->Count;
+	/* Duration */
+	RTMPMoveMemory((pDest+6), pNoa->Duration, 4);
+	/* Interval */
+	RTMPMoveMemory((pDest+10), pNoa->Interval, 4);
+	RTMPMoveMemory((pDest+14), &StartTime, 4);
+}
+
+
+BOOLEAN	CFG80211_P2pAdjustSwNoATimer(PRTMP_ADAPTER pAd, ULONG CurrentTimeStamp, ULONG NextTimePoint) 
+{
+	PCFG80211_CTRL pP2PCtrl = &pAd->cfg80211_ctrl;	
+	ULONG AwakeDuration, NewStartTime;
+	UCHAR FakeNoAAttribute[32];
+	
+	RTMPZeroMemory(FakeNoAAttribute, 32);
+	AwakeDuration = pP2PCtrl->GONoASchedule.Interval - pP2PCtrl->GONoASchedule.Duration;
+	if (CurrentTimeStamp < pP2PCtrl->GONoASchedule.CurrentTargetTimePoint)
+	{
+		/* If offset is more than 1/4 of duration. */
+		if ((pP2PCtrl->GONoASchedule.OngoingAwakeTime) >= (AwakeDuration>> 2))
+		{
+			DBGPRINT(RT_DEBUG_TRACE,("P2pAdjustSwNoATimer HERE HERE!!!! \n"));
+			DBGPRINT(RT_DEBUG_TRACE,("OngoingAwakeTime = %ld. CurrentTimeStamp = %ld.!!!! \n", 
+							pP2PCtrl->GONoASchedule.OngoingAwakeTime, CurrentTimeStamp));
+
+			CFG80211_P2pStopNoA(pAd, &pAd->MacTab.Content[pP2PCtrl->MyGOwcid]);
+			FakeNoAAttribute[0] = SUBID_P2P_NOA;
+			NewStartTime = pP2PCtrl->GONoASchedule.StartTime + 
+				       (pP2PCtrl->GONoASchedule.SwTimerTickCounter - 1) * (pP2PCtrl->GONoASchedule.Interval);
+
+			CFG80211_P2PMakeFakeNoATlv(pAd, NewStartTime, &FakeNoAAttribute[0]);
+
+			pAd->MacTab.Content[pP2PCtrl->MyGOwcid].CFGP2pInfo.NoADesc[0].Token--;
+
+			CFG80211_P2pHandleNoAAttri(pAd, &pAd->MacTab.Content[pP2PCtrl->MyGOwcid], &FakeNoAAttribute[0]);
+		}
+
+		/* Update expected next Current Target Time Point with NextTimePoint */
+		pP2PCtrl->GONoASchedule.CurrentTargetTimePoint = NextTimePoint;
+		/* Can immediately dequeue packet because peer already in awake period. */
+		return TRUE;
+	}
+	else
+	{
+		/* Update expected next Current Target Time Point with NextTimePoint */
+		pP2PCtrl->GONoASchedule.CurrentTargetTimePoint = NextTimePoint;
+		return FALSE;	
+	}
+}
+
+VOID CFG80211_P2pGPTimeOutHandle(PRTMP_ADAPTER pAd) 
+{
+	PCFG80211_CTRL pP2PCtrl = &pAd->cfg80211_ctrl;
+	MAC_TABLE_ENTRY *pEntry=NULL;
+	ULONG MacValue, Value, GPDiff, NextDiff, SavedNextTargetTimePoint;
+
+	RTMP_IO_READ32(pAd, INT_TIMER_EN, &Value);
+	Value &= 0xfffffffd;
+	RTMP_IO_WRITE32(pAd, INT_TIMER_EN, Value);
+	
+	/* GO operating or Autonomous GO */
+	if (CFG_P2PGO_ON(pAd))
+	{
+		/* Not Yet Ready */
+	}
+	else if (CFG_P2PCLI_ON(pAd))
+	{
+		if (pP2PCtrl->NoAIndex >= MAX_LEN_OF_MAC_TABLE)
+			return;
+	
+		if (pP2PCtrl->NoAIndex != pP2PCtrl->MyGOwcid)
+			DBGPRINT(RT_DEBUG_TRACE,("%s: !bug, please check driver %d. \n", 
+				__FUNCTION__, pP2PCtrl->NoAIndex));
+				
+		pEntry = &pAd->MacTab.Content[pP2PCtrl->NoAIndex];
+		if (pEntry && pEntry->CFGP2pInfo.NoADesc[0].bValid == TRUE)
+		{
+			if ((pEntry->CFGP2pInfo.NoADesc[0].Count > 0) && (pEntry->CFGP2pInfo.NoADesc[0].Count < 255))
+			{
+				/*
+					Sometimes go to awake, sometime go to silence. Two state counts One count down.
+					so only minus Count when I change from Sleep to Awake
+				 */
+				if (pEntry->CFGP2pInfo.NoADesc[0].bInAwake == FALSE)
+					pEntry->CFGP2pInfo.NoADesc[0].Count--;
+			}
+
+			if (pEntry->CFGP2pInfo.NoADesc[0].Count == 0)
+			{
+				CFG80211_P2pStopNoA(pAd, pEntry);
+				DBGPRINT(RT_DEBUG_TRACE,("P2P_PS %s: Count down to zero!!StopGP.  return.1 \n", __FUNCTION__));
+				return;
+			}
+	
+			/* To enter absence period, stop transmission a little bit earlier to leave HW to clean the queue. */
+			if (pEntry->CFGP2pInfo.NoADesc[0].bInAwake == FALSE)
+				NextDiff = pEntry->CFGP2pInfo.NoADesc[0].Duration - 0x200;
+			else
+				NextDiff = pEntry->CFGP2pInfo.NoADesc[0].Interval - pEntry->CFGP2pInfo.NoADesc[0].Duration + 0x200;
+
+			/* Prepare next time. */
+
+
+			/*RTMP_IO_READ32(pAd, TSF_TIMER_DW0, &MacValue); */
+			MacValue = pAd->cfg80211_ctrl.GONoASchedule.LastBeaconTimeStamp;
+			DBGPRINT(RT_DEBUG_TRACE,("P2P_PS 2 Tsf	Timer  = %ld,  NextTargetTimePoint = %ld.\n", 
+				MacValue, pEntry->CFGP2pInfo.NoADesc[0].NextTargetTimePoint));
+
+			SavedNextTargetTimePoint = pEntry->CFGP2pInfo.NoADesc[0].NextTargetTimePoint;
+			if (MacValue <= pEntry->CFGP2pInfo.NoADesc[0].NextTargetTimePoint)
+			{
+				GPDiff = pEntry->CFGP2pInfo.NoADesc[0].NextTargetTimePoint - MacValue;
+
+				pEntry->CFGP2pInfo.NoADesc[0].NextTargetTimePoint += NextDiff;
+				CFG80211_P2pResetNoATimer(pAd, GPDiff);
+				DBGPRINT(RT_DEBUG_TRACE,("P2P_PS 3	Continue next NOA NextTargetTimePoint = %ld. \n", 
+						pEntry->CFGP2pInfo.NoADesc[0].NextTargetTimePoint));
+				DBGPRINT(RT_DEBUG_TRACE,("P2P_PS 3	Value = %ld.  NextDiff = %ld.\n", MacValue, NextDiff));
+			}
+			else
+			{
+				CFG80211_P2pStopNoA(pAd, pEntry);
+				DBGPRINT(RT_DEBUG_TRACE,("P2P_PS 4  NOA NextTargetTimePoint = %ld. \n", 
+							pEntry->CFGP2pInfo.NoADesc[0].NextTargetTimePoint));
+				DBGPRINT(RT_DEBUG_TRACE,("P2P_PS 4  Value = %ld = 0x%lx.  NextDiff = %ld.\n", MacValue,  MacValue, NextDiff));
+				return;
+			}
+					
+			if (pEntry->CFGP2pInfo.NoADesc[0].bInAwake == TRUE)
+			{
+				pEntry->CFGP2pInfo.NoADesc[0].bInAwake = FALSE;
+				pP2PCtrl->bKeepSlient = TRUE;
+				pP2PCtrl->bPreKeepSlient = TRUE;
+				DBGPRINT(RT_DEBUG_TRACE,("P2P_PS Enter Absence now ======> %d\n", pP2PCtrl->bKeepSlient));
+			}
+			else
+			{
+				pEntry->CFGP2pInfo.NoADesc[0].bInAwake = TRUE;
+				pP2PCtrl->bKeepSlient = FALSE;
+				pP2PCtrl->bPreKeepSlient = FALSE;
+				if (IS_SW_NOA_TIMER(pAd) && (pP2PCtrl->GONoASchedule.Count > 100))
+				{
+					if (TRUE == CFG80211_P2pAdjustSwNoATimer(pAd, Value, SavedNextTargetTimePoint))
+					{
+						RTMPDeQueuePacket(pAd, FALSE, NUM_OF_TX_RING, MAX_TX_PROCESS);
+					}
+				}
+				else
+				{
+					RTMPDeQueuePacket(pAd, FALSE, NUM_OF_TX_RING, MAX_TX_PROCESS);
+				}
+
+				DBGPRINT(RT_DEBUG_TRACE,("P2P_PS Enter Awake now ======= %d\n", pAd->cfg80211_ctrl.bKeepSlient));
+	
+			}
+	
+		}
+					
+	}
+}
+
+VOID CFG80211_P2PCTWindowTimer(
+	PVOID SystemSpecific1, PVOID FunctionContext, 
+	PVOID SystemSpecific2, PVOID SystemSpecific3) 
+{
+	PRTMP_ADAPTER	pAd = (RTMP_ADAPTER *)FunctionContext;
+	PCFG80211_CTRL pP2pCtrl = &pAd->cfg80211_ctrl;	
+
+	if (CFG80211_P2P_TEST_BIT(pP2pCtrl->CTWindows, P2P_OPPS_BIT))
+		pP2pCtrl->bKeepSlient = TRUE;
+}
+
+
+/*	
+	==========================================================================
+	Description: 
+		When I am P2P Client , Handle NoA Attribute.
+		
+	Parameters: 
+		S - pointer to the association state machine
+	Note:
+		The state machine looks like the following as name implies its function
+	==========================================================================
+ */
+VOID CFG80211_P2pSwNoATimeOut(
+	PVOID SystemSpecific1, PVOID FunctionContext, 
+	PVOID SystemSpecific2, PVOID SystemSpecific3) 
+{
+	PRTMP_ADAPTER pAd = (RTMP_ADAPTER *)FunctionContext;
+	CFG80211_P2pGPTimeOutHandle(pAd);
+}
+
+VOID CFG80211_P2pPreAbsenTimeOut(
+	PVOID SystemSpecific1, PVOID FunctionContext, 
+	PVOID SystemSpecific2, PVOID SystemSpecific3) 
+{
+	PRTMP_ADAPTER pAd = (RTMP_ADAPTER *)FunctionContext;
+	pAd->cfg80211_ctrl.bPreKeepSlient = TRUE;
+}
+
+
+BOOLEAN CFG80211_P2pResetNoATimer(PRTMP_ADAPTER pAd, ULONG DiffTimeInUs)
+{
+	ULONG	GPDiff;
+	BOOLEAN	brc = FALSE;
+
+	/*
+		Software based timer means don't use GP interrupt to get precise timer calculation. 
+		So need to check time offset caused by software timer.
+	 */
+	if (IS_SW_NOA_TIMER(pAd))
+	{
+		GPDiff = (DiffTimeInUs>>10) & 0xffff;
+		printk("P2P_PS ==========> P2pResetNoATimer, %ld ==> %d\n", DiffTimeInUs, GPDiff);
+		if (GPDiff > 0)
+		{
+			GPDiff++;
+			RTMPSetTimer(&pAd->cfg80211_ctrl.P2pSwNoATimer, GPDiff);			
+			
+			/* Increase timer tick counter. */
+			pAd->cfg80211_ctrl.GONoASchedule.SwTimerTickCounter++;
+
+			brc = TRUE;
+			/* Will go to awake later. Set a pre-enter-absence timer that the time out is smaller the GPDiff. */
+			if (pAd->cfg80211_ctrl.GONoASchedule.bInAwake == FALSE)			
+			{
+				if (GPDiff > 10)
+				{
+					printk("P2P_PS ==========> P2pPreAbsenTimer, %d\n", (GPDiff - 10));
+					RTMPSetTimer(&pAd->cfg80211_ctrl.P2pPreAbsenTimer, (GPDiff - 10));					
+				}
+			}
+		}
+	}
+	return brc;
+
+}
+
+
+VOID CFG80211_P2pGOStartNoA(PRTMP_ADAPTER pAd)
+{
+
+}
+
+VOID	CFG80211_P2pStopNoA(PRTMP_ADAPTER pAd, PMAC_TABLE_ENTRY pMacClient)
+{
+	ULONG	Value;
+	BOOLEAN	Cancelled;
+	
+	DBGPRINT(RT_DEBUG_TRACE,("P2P_PS %s .!!!! \n",__FUNCTION__));
+	
+	RTMPCancelTimer(&pAd->cfg80211_ctrl.P2pPreAbsenTimer, &Cancelled);
+	pAd->cfg80211_ctrl.bKeepSlient = FALSE;
+	pAd->cfg80211_ctrl.bPreKeepSlient = FALSE;
+	if (pMacClient != NULL)
+	{
+		pMacClient->CFGP2pInfo.NoADesc[0].Count = 0xf3;
+		pMacClient->CFGP2pInfo.NoADesc[0].bValid = FALSE;
+		pMacClient->CFGP2pInfo.NoADesc[0].bInAwake = TRUE;
+		/*
+			Try set Token to a value that has smallest chane the same as the Next Token GO will use.
+			So decrease 1
+		 */
+		pMacClient->CFGP2pInfo.NoADesc[0].Token--;
+	}
+	RTMPCancelTimer(&pAd->cfg80211_ctrl.P2pSwNoATimer, &Cancelled);
+	pAd->cfg80211_ctrl.GONoASchedule.bValid = FALSE;
+	pAd->cfg80211_ctrl.GONoASchedule.bInAwake = TRUE;
+
+		
+	/* If need not resume NoA. Can reset all parameters. */
+	{
+		pAd->cfg80211_ctrl.GONoASchedule.Count = 1;
+		pAd->cfg80211_ctrl.GONoASchedule.Duration = 0xc800;
+		pAd->cfg80211_ctrl.GONoASchedule.Interval = 0x19000;
+	}
+
+	RTMP_IO_READ32(pAd, INT_TIMER_EN, &Value);
+	Value &= (0xfffffffd);
+	RTMP_IO_WRITE32(pAd, INT_TIMER_EN, Value);
+
+	pAd->cfg80211_ctrl.GONoASchedule.SwTimerTickCounter = 0;
+
+	/* Set to false again. */
+	pAd->cfg80211_ctrl.bPreKeepSlient = FALSE;
+
+}
+
+VOID CFG80211_P2pStartOpPS(PRTMP_ADAPTER pAd)
+{
+	if (pAd->cfg80211_ctrl.GONoASchedule.bValid == TRUE)
+		CFG80211_P2pStopNoA(pAd, NULL);
+	
+	DBGPRINT(RT_DEBUG_TRACE,("P2P : !! %s \n",__FUNCTION__));
+	pAd->cfg80211_ctrl.CTWindows = 0x8a;
+	/* Wait next beacon period to really start queue packet. */
+	pAd->cfg80211_ctrl.bKeepSlient = FALSE;
+
+}
+
+VOID CFG80211_P2pStopOpPS(PRTMP_ADAPTER pAd)
+{
+	if (pAd->cfg80211_ctrl.GONoASchedule.bValid == FALSE)
+		pAd->cfg80211_ctrl.bKeepSlient = FALSE;
+	pAd->cfg80211_ctrl.CTWindows = 0;
+}
+
+static
+ULONG CFG80211_P2pGetTimeStamp(PRTMP_ADAPTER pAd)
+{
+	ULONG Value = 0;	
+	/* RTMP_IO_FORCE_READ32(pAd, TSF_TIMER_DW0, &Value); */
+        Value = pAd->cfg80211_ctrl.GONoASchedule.LastBeaconTimeStamp;
+	
+	return Value;
+}
+
+BOOLEAN CFG80211_P2pHandleNoAAttri(PRTMP_ADAPTER pAd, PMAC_TABLE_ENTRY pMacClient, PUCHAR pData) 
+{
+	PP2P_NOA_DESC pNoADesc;
+	ULONG Value, GPDiff, NoALen, StartTime;
+	UCHAR index;
+	
+	if (pMacClient == NULL)
+		return FALSE;
+
+	if (*pData == SUBID_P2P_NOA)
+	{
+		NoALen = *(pData+1);
+		if (NoALen == 2)
+		{
+			pMacClient->CFGP2pInfo.CTWindow = *(pData+4); 
+			if (pMacClient->CFGP2pInfo.NoADesc[0].bValid == TRUE)
+				CFG80211_P2pStopNoA(pAd, pMacClient);
+			/*
+				Copy my GO's CTWindow to P2Pcfg.CTWindow parameters, 
+				Then As Client, I don't need to search for Client when I want to use CTWindow Value.
+			 */
+			pAd->cfg80211_ctrl.CTWindows = *(pData+4); 
+			return TRUE;
+		}
+			
+		index = *(pData+3);
+		
+		pMacClient->CFGP2pInfo.CTWindow = *(pData+4);
+		pAd->cfg80211_ctrl.CTWindows = *(pData+4); 
+		
+		pNoADesc = (PP2P_NOA_DESC)(pData+5);
+		pMacClient->CFGP2pInfo.NoADesc[0].Count = pNoADesc->Count;
+		pMacClient->CFGP2pInfo.NoADesc[0].Duration = *(PUINT32)&pNoADesc->Duration[0];
+		pMacClient->CFGP2pInfo.NoADesc[0].Interval = *(PUINT32)&pNoADesc->Interval[0];
+		pMacClient->CFGP2pInfo.NoADesc[0].StartTime = *(PUINT32)&pNoADesc->StartTime[0];
+		StartTime = *(PUINT32)&pNoADesc->StartTime[0];
+	
+		if (pMacClient->CFGP2pInfo.NoADesc[0].Token == index)
+		{
+			/* The same NoA. Doesn't need to set this NoA again. */
+			return FALSE;
+		}
+		
+		DBGPRINT(RT_DEBUG_TRACE,("P2P_PS : !!!NEW NOA Here =[%d, %d] Count = %d. Duration =  %ld \n", 
+					pMacClient->CFGP2pInfo.NoADesc[0].Token, index, pNoADesc->Count, 
+					pMacClient->CFGP2pInfo.NoADesc[0].Duration));
+		DBGPRINT(RT_DEBUG_TRACE,("P2P_PS : CTWindow =  %x \n", pMacClient->CFGP2pInfo.CTWindow));
+
+		pMacClient->CFGP2pInfo.NoADesc[0].Token = index;
+
+
+		/* RTMP_IO_FORCE_READ32(pAd, TSF_TIMER_DW0, &Value); */
+		Value = pAd->cfg80211_ctrl.GONoASchedule.LastBeaconTimeStamp;
+		DBGPRINT(RT_DEBUG_TRACE,("P2P_PS Interval = %ld. StartTime = %ld. TSF timer = %ld\n", 
+			pMacClient->CFGP2pInfo.NoADesc[0].Interval, pMacClient->CFGP2pInfo.NoADesc[0].StartTime, Value));
+
+		if ((pMacClient->CFGP2pInfo.NoADesc[0].Duration <= 0x40) || (pMacClient->CFGP2pInfo.NoADesc[0].Interval <= 0x40))
+		{
+			DBGPRINT(RT_DEBUG_TRACE, ("P2P_PS !!!!!Interval or Duration too small. ignore.  = %lx return 1\n", Value));
+			return FALSE;
+		}
+		else if ((pMacClient->CFGP2pInfo.NoADesc[0].Duration >= pMacClient->CFGP2pInfo.NoADesc[0].Interval)
+			&& (pMacClient->CFGP2pInfo.NoADesc[0].Count > 1))
+		{
+			DBGPRINT(RT_DEBUG_TRACE, ("P2P_PS !!!!!Duration > Inveral.  return 2\n"));
+			return FALSE;
+		}
+		
+		/* if Start time point is in the future. */
+		pAd->cfg80211_ctrl.GONoASchedule.CurrentTargetTimePoint = pMacClient->CFGP2pInfo.NoADesc[0].StartTime;
+		if (Value < StartTime)
+		{
+			GPDiff = pMacClient->CFGP2pInfo.NoADesc[0].StartTime - Value;
+			pMacClient->CFGP2pInfo.NoADesc[0].NextTargetTimePoint = 
+					pMacClient->CFGP2pInfo.NoADesc[0].StartTime + pMacClient->CFGP2pInfo.NoADesc[0].Duration;
+			pAd->cfg80211_ctrl.GONoASchedule.OngoingAwakeTime = 
+					pMacClient->CFGP2pInfo.NoADesc[0].NextTargetTimePoint;
+
+						
+			DBGPRINT(RT_DEBUG_TRACE,("P2P_PS !!!!! GPDiff = %ld. NextTargetTimePoint = %ld\n", 
+					GPDiff, pMacClient->CFGP2pInfo.NoADesc[0].NextTargetTimePoint));
+
+			/* try to set General Timer. */
+			pAd->cfg80211_ctrl.GONoASchedule.LastBeaconTimeStamp += GPDiff;
+			if (CFG80211_P2pResetNoATimer(pAd, GPDiff))
+			{
+				DBGPRINT(RT_DEBUG_TRACE,("P2P_PS !!!!!Start NoA 1  GPDiff = %ld \n", GPDiff));
+				pMacClient->CFGP2pInfo.NoADesc[0].bValid = TRUE;
+				pMacClient->CFGP2pInfo.NoADesc[0].bInAwake = TRUE;
+				pMacClient->CFGP2pInfo.NoADesc[0].Token = index;
+				return TRUE;
+			}
+		}
+		else if (Value >= StartTime)
+		{
+			/* Start time point is in the past. */
+			do
+			{
+				StartTime += pMacClient->CFGP2pInfo.NoADesc[0].Interval;
+				if ((StartTime > Value) && ((StartTime-Value) > 0x80))
+				{
+					GPDiff = StartTime - Value;
+					pMacClient->CFGP2pInfo.NoADesc[0].NextTargetTimePoint = StartTime 
+								/* + pMacClient->P2pInfo.NoADesc[0].Interval */ 
+								  - pMacClient->CFGP2pInfo.NoADesc[0].Duration;
+
+					pAd->cfg80211_ctrl.GONoASchedule.OngoingAwakeTime = 
+								pMacClient->CFGP2pInfo.NoADesc[0].NextTargetTimePoint;
+					pAd->cfg80211_ctrl.GONoASchedule.LastBeaconTimeStamp += GPDiff;
+
+					if (CFG80211_P2pResetNoATimer(pAd, GPDiff))
+					{
+						DBGPRINT(RT_DEBUG_TRACE,("P2P_PS !!!!!Start NoA 2  GPDiff = %ld\n", GPDiff));
+						pMacClient->CFGP2pInfo.NoADesc[0].bValid = TRUE;
+						pMacClient->CFGP2pInfo.NoADesc[0].bInAwake = TRUE;
+						pMacClient->CFGP2pInfo.NoADesc[0].Token = index;
+						return TRUE;
+					}
+				}
+
+			} while(TRUE);
+		}
+		else
+		{
+			DBGPRINT(RT_DEBUG_ERROR, ("Start time out of ctrl ..need Check \n"));
+		}
+	}
+
+	return FALSE;
+}
+
+
+VOID CFG80211_P2pParseNoASubElmt(PRTMP_ADAPTER pAd, VOID *Msg, ULONG MsgLen, 
+                                 UCHAR wcidindex, UINT32 Sequence)
+{
+	PCFG80211_CTRL pP2PCtrl = &pAd->cfg80211_ctrl;
+	ULONG Length = 0, AttriLen = 0, LeftLength = 0;
+	PP2PEID_STRUCT pP2pEid;
+	PEID_STRUCT pEid;
+	BOOLEAN brc = FALSE, bNoAAttriExist = FALSE;
+	PUCHAR pPtrEid = NULL;
+		
+	/* Intel sends multiple P2P IE... So I can't give each input a default value.. */
+	if (MsgLen == 0)
+		return;
+	
+	LeftLength = MsgLen; 
+	pEid = (PEID_STRUCT)Msg;
+	while ((ULONG)(pEid->Len + 2) <= LeftLength)
+	{
+		/* might contains P2P IE and WPS IE.  So use if else if enough for locate  P2P IE. */
+		if (RTMPEqualMemory(&pEid->Octet[0], CFG_P2POUIBYTE, 4))
+		{
+			/* Get Request content capability */
+			pP2pEid = (PP2PEID_STRUCT) &pEid->Octet[4];
+			pPtrEid = (PUCHAR) pP2pEid;
+			AttriLen = pP2pEid->Len[0] + pP2pEid->Len[1] *8;
+			Length = 0;
+
+			while ((Length + 3 + AttriLen) <= pEid->Len)	
+			{
+				switch(pP2pEid->Eid)
+				{
+					case SUBID_P2P_NOA:
+					{
+						PUCHAR pData = &pEid->Octet[0];
+						DBGPRINT(RT_DEBUG_TRACE, ("P2P_PS Get NoA Attr: %x %x %x %x %x %x %x %x %x \n", 
+									*(pData+0), *(pData+1), *(pData+2), *(pData+3), 
+									*(pData+4), *(pData+5), *(pData+6), *(pData+7), *(pData+8)));
+
+						bNoAAttriExist = TRUE;
+						brc = CFG80211_P2pHandleNoAAttri(pAd, &pAd->MacTab.Content[wcidindex], pPtrEid);
+
+						/* Got a NoA Attribute from this p2pindex. In fact, This should be GO. */
+						if (brc == TRUE)
+							pP2PCtrl->NoAIndex = wcidindex;
+					}
+						break;
+
+					default:
+						break;
+						
+				}
+
+				Length = Length + 3 + AttriLen;  /* Eid[1] + Len[1]+ content[Len] */
+				pP2pEid = (PP2PEID_STRUCT)((UCHAR*)pP2pEid + 3 + AttriLen);
+				pPtrEid = (PUCHAR) pP2pEid;
+				AttriLen = pP2pEid->Len[0] + pP2pEid->Len[1] *8;
+			}	
+		}
+		LeftLength = LeftLength - pEid->Len - 2;
+		pEid = (PEID_STRUCT)((UCHAR*)pEid + 2 + pEid->Len); 	   
+	}
+
+	if (bNoAAttriExist == FALSE)
+	{
+		if (CFG80211_P2P_TEST_BIT(pAd->cfg80211_ctrl.CTWindows, P2P_OPPS_BIT))
+		{
+			DBGPRINT(RT_DEBUG_TRACE,("Beacon and no NoA Attribute! \n"));
+			CFG80211_P2pStopOpPS(pAd);
+		}
+
+		if ((pAd->MacTab.Content[wcidindex].CFGP2pInfo.NoADesc[0].bValid == TRUE))
+		{
+			DBGPRINT(RT_DEBUG_TRACE,("Beacon and no NoA Attribute!Stop active NoA [%d]\n", Sequence));
+			CFG80211_P2pStopNoA(pAd, &pAd->MacTab.Content[wcidindex]);
+		}
+	}
+	else
+		printk("P2P_PS Debug: %s() %d ===> Get Entry\n", __FUNCTION__, __LINE__);
+
+}
+
+
+BOOLEAN CFG8211_PeerP2pBeaconSanity(
+	PRTMP_ADAPTER pAd, VOID *Msg, ULONG MsgLen, 
+	PUCHAR pAddr2, CHAR Ssid[], UCHAR *pSsidLen, 
+	ULONG *Peerip, ULONG *P2PSubelementLen, 
+	PUCHAR pP2pSubelement) 
+{
+	PFRAME_802_11 pFrame;
+	PEID_STRUCT pEid;
+	ULONG Length = 0;
+	BOOLEAN	brc = FALSE, bFirstP2pOUI = TRUE;
+	PUCHAR Ptr;
+
+	pFrame = (PFRAME_802_11)Msg;
+	Length += LENGTH_802_11;
+
+	*P2PSubelementLen = 0;
+	*pSsidLen = 0;
+	*Peerip = 0;
+	COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
+
+	Ptr = pFrame->Octet;
+
+	/* get timestamp from payload and advance the pointer */
+	Ptr += TIMESTAMP_LEN;
+	Length += TIMESTAMP_LEN;
+
+	/* get beacon interval from payload and advance the pointer */
+	Ptr += 2;
+	Length += 2;
+
+	/* get capability info from payload and advance the pointer */
+	Ptr += 2;
+	Length += 2;
+
+	pEid = (PEID_STRUCT) Ptr;
+
+	/* get variable fields from payload and advance the pointer */
+	while ((Length + 2 + pEid->Len) <= MsgLen)    
+	{
+		switch(pEid->Eid)
+		{			
+			case IE_SSID:
+				if(pEid->Len <= MAX_LEN_OF_SSID)
+				{
+					RTMPMoveMemory(Ssid, pEid->Octet, pEid->Len);
+					*pSsidLen = pEid->Len;
+				}
+				break;
+			case IE_VENDOR_SPECIFIC:
+				/* Check the OUI version, filter out non-standard usage */
+				if (NdisEqualMemory(pEid->Octet, CFG_WPS_OUI, 4) && (pEid->Len >= 4))
+				{
+					if (*P2PSubelementLen == 0)
+					{
+						RTMPMoveMemory(pP2pSubelement, &pEid->Eid, pEid->Len +2);
+						*P2PSubelementLen = pEid->Len +2;
+					}
+					else if (*P2PSubelementLen > 0)
+					{
+						if (((*P2PSubelementLen) + (pEid->Len+2)) <= MAX_VIE_LEN)
+						{
+							RTMPMoveMemory(pP2pSubelement + *P2PSubelementLen, &pEid->Eid, pEid->Len+2);
+							*P2PSubelementLen += (pEid->Len+2);
+						}
+						else
+						{
+							DBGPRINT(RT_DEBUG_ERROR, ("%s: ERROR!! 111 Sum of P2PSubelementLen= %lu, > MAX_VIE_LEN !!\n", __FUNCTION__, ((*P2PSubelementLen) + (pEid->Len+2))));
+							return FALSE;
+						}
+					}
+
+				}
+				else if (NdisEqualMemory(pEid->Octet, CFG_P2POUIBYTE, 4) && (pEid->Len >= 4))
+				{
+					/*
+						If this is the first P2P OUI. Then also append P2P OUI. 
+						Beacon 's P2P attribute doesn't exceed 256 bytes. So not use acumulcated form.
+					 */
+					if (bFirstP2pOUI == TRUE)
+					{
+						if (*P2PSubelementLen == 0)
+						{
+							RTMPMoveMemory(pP2pSubelement, &pEid->Eid, pEid->Len +2);
+							*P2PSubelementLen = (pEid->Len +2);
+							brc = TRUE;
+						}
+						else if (*P2PSubelementLen > 0)
+						{
+							if (((*P2PSubelementLen) + (pEid->Len+2)) <= MAX_VIE_LEN)
+							{
+								RTMPMoveMemory(pP2pSubelement + *P2PSubelementLen, &pEid->Eid, pEid->Len+2);
+								*P2PSubelementLen += (pEid->Len+2);
+								brc = TRUE;
+							}
+							else
+							{
+								DBGPRINT(RT_DEBUG_ERROR, ("%s: ERROR!! 222 Sum of P2PSubelementLen= %lu, > MAX_VIE_LEN !!\n", __FUNCTION__, ((*P2PSubelementLen) + (pEid->Len+2))));
+								return FALSE;
+							}
+						}
+						bFirstP2pOUI = FALSE;
+					}
+					else
+					{
+						/*
+							If this is not the first P2P OUI. Then don't append P2P OUI.
+							because our parse function doesn't need so many P2P OUI.
+						 */
+						if ((*P2PSubelementLen > 0) && (pEid->Len > 4))
+						{
+							if (((*P2PSubelementLen) + (pEid->Len+2)) <= MAX_VIE_LEN)
+							{
+								RTMPMoveMemory(pP2pSubelement + *P2PSubelementLen, &pEid->Eid, pEid->Len+2);
+								*P2PSubelementLen += (pEid->Len+2);
+								brc = TRUE;
+							}
+							else
+							{
+								DBGPRINT(RT_DEBUG_ERROR, ("%s: ERROR!! 333 Sum of P2PSubelementLen= %lu, > MAX_VIE_LEN !!\n", __FUNCTION__, ((*P2PSubelementLen) + (pEid->Len+2))));
+								return FALSE;
+							}
+						}
+					}
+				}
+				break;
+		}
+		Length = Length + 2 + pEid->Len;  /* Eid[1] + Len[1]+ content[Len] */
+		pEid = (PEID_STRUCT)((UCHAR*)pEid + 2 + pEid->Len);        
+	
+	}
+	return brc;
+}
+
+
+VOID CFG80211_PeerP2pBeacon(PRTMP_ADAPTER pAd, 
+	PUCHAR pAddr2, MLME_QUEUE_ELEM *Elem, LARGE_INTEGER TimeStamp) 
+{
+	PCFG80211_CTRL pP2PCtrl = &pAd->cfg80211_ctrl;
+	
+	UCHAR	Addr2[6], SsidLen, Ssid[32];
+	ULONG	PeerIp, P2PSubelementLen;
+	PUCHAR	P2pSubelement = NULL;
+	PFRAME_802_11		pFrame;
+	PMAC_TABLE_ENTRY pMacEntry = NULL;
+
+	pFrame = (PFRAME_802_11)Elem->Msg;
+	/* Only check beacon . */
+	if (pFrame->Hdr.FC.SubType == SUBTYPE_PROBE_RSP)
+		return;
+
+	if (Elem->Wcid >= MAX_LEN_OF_MAC_TABLE)
+		return;
+
+	pMacEntry = &pAd->MacTab.Content[Elem->Wcid];
+
+	/* Init P2pSubelement */
+       	if (P2pSubelement)
+        {
+                os_free_mem(NULL, P2pSubelement);
+                P2pSubelement = NULL;
+        }
+
+	os_alloc_mem(pAd, &P2pSubelement, MAX_VIE_LEN);
+	if (P2pSubelement == NULL)
+	{
+		DBGPRINT(RT_DEBUG_ERROR, ("%s::Allocate memory size(=%d) failed\n", __FUNCTION__, MAX_VIE_LEN));
+		goto CleanUp;
+	}
+	
+	if (CFG8211_PeerP2pBeaconSanity(pAd, Elem->Msg, Elem->MsgLen, 
+					Addr2, Ssid, &SsidLen, &PeerIp,
+					&P2PSubelementLen,P2pSubelement))
+	{
+		/* Parse the power managemenr parameters in here. */
+		pP2PCtrl->GONoASchedule.LastBeaconTimeStamp = TimeStamp.u.LowPart;
+		CFG80211_P2pParseNoASubElmt(pAd, P2pSubelement, P2PSubelementLen, Elem->Wcid, pFrame->Hdr.Sequence);
+
+		/* Since we get beacon, check if GO enable and OppPS. */
+		if (CFG80211_P2P_TEST_BIT(pAd->cfg80211_ctrl.CTWindows, P2P_OPPS_BIT))
+		{
+			pAd->cfg80211_ctrl.bKeepSlient = FALSE;
+			/* TO DO : sync with windows if necessary */
+			/*RTMPDeQueueNoAMgmtPacket(pAd);*/
+
+			RTMPDeQueuePacket(pAd, FALSE, NUM_OF_TX_RING, MAX_TX_PROCESS);
+			if (((pAd->cfg80211_ctrl.CTWindows&0x7f) > 0) && ((pAd->cfg80211_ctrl.CTWindows&0x7f) < 80))
+			{
+				DBGPRINT(RT_DEBUG_TRACE, ("%s::  set P2P CTWindows timer.\n", __FUNCTION__));
+				RTMPSetTimer(&pAd->cfg80211_ctrl.P2pCTWindowTimer, (pAd->cfg80211_ctrl.CTWindows&0x7f));
+			}
+		}
+	}
+	
+CleanUp:
+	if (P2pSubelement)
+	{
+		os_free_mem(NULL, P2pSubelement);
+		P2pSubelement = NULL;
+	}
+
+}
+
+#ifdef RT_CFG80211_P2P_CONCURRENT_DEVICE
+VOID CFG80211_P2pClientSendNullFrame(VOID *pAdCB, INT PwrMgmt)
+{
+        PRTMP_ADAPTER pAd = (PRTMP_ADAPTER)pAdCB;
+        MAC_TABLE_ENTRY *pEntry;
+
+        pEntry = MacTableLookup(pAd, pAd->ApCfg.ApCliTab[MAIN_MBSSID].MlmeAux.Bssid);
+        if (pEntry == NULL)
+        {
+                DBGPRINT(RT_DEBUG_TRACE, ("CFG80211_ROC: Can't Find In Table: %02x:%02x:%02x:%02x:%02x:%02x\n",
+                                                   PRINT_MAC(pAd->ApCfg.ApCliTab[MAIN_MBSSID].MlmeAux.Bssid)));
+        }
+        else
+        {
+                ApCliRTMPSendNullFrame(pAd,
+                                       RATE_6,
+                                       (CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_WMM_CAPABLE)) ? TRUE:FALSE,
+                                       pEntry, PwrMgmt);
+                OS_WAIT(20);
+        }
+}
+
+VOID CFG80211DRV_P2pClientKeyAdd(VOID *pAdOrg, VOID *pData)
+{
+
+	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER)pAdOrg;
+	CMD_RTPRIV_IOCTL_80211_KEY *pKeyInfo;
+	
+    	DBGPRINT(RT_DEBUG_TRACE, ("CFG Debug: CFG80211DRV_P2pClientKeyAdd\n"));
+    	pKeyInfo = (CMD_RTPRIV_IOCTL_80211_KEY *)pData;
+	
+	if (pKeyInfo->KeyType == RT_CMD_80211_KEY_WEP40 || pKeyInfo->KeyType == RT_CMD_80211_KEY_WEP104)
+		;
+	else
+	{	
+		INT 	BssIdx;
+		PAPCLI_STRUCT pApCliEntry;
+		MAC_TABLE_ENTRY	*pMacEntry=(MAC_TABLE_ENTRY *)NULL;
+	
+		BssIdx = pAd->ApCfg.BssidNum + MAX_MESH_NUM + MAIN_MBSSID;
+		pApCliEntry = &pAd->ApCfg.ApCliTab[MAIN_MBSSID];
+		pMacEntry = &pAd->MacTab.Content[pApCliEntry->MacTabWCID]; 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+        	if (pKeyInfo->bPairwise == FALSE )
+#else
+        	if (pKeyInfo->KeyId > 0)
+#endif		
+		{
+			
+			if (pApCliEntry->wdev.WepStatus == Ndis802_11Encryption3Enabled)
+			{
+				printk("APCLI: Set AES Security Set. [%d] (GROUP) %d\n", BssIdx, pKeyInfo->KeyLen);
+				NdisZeroMemory(&pApCliEntry->SharedKey[pKeyInfo->KeyId], sizeof(CIPHER_KEY));  
+				pApCliEntry->SharedKey[pKeyInfo->KeyId].KeyLen = LEN_TK;
+				NdisMoveMemory(pApCliEntry->SharedKey[pKeyInfo->KeyId].Key, pKeyInfo->KeyBuf, pKeyInfo->KeyLen);
+				
+				pApCliEntry->SharedKey[pKeyInfo->KeyId].CipherAlg = CIPHER_AES;
+
+				AsicAddSharedKeyEntry(pAd, BssIdx, pKeyInfo->KeyId, 
+						      &pApCliEntry->SharedKey[pKeyInfo->KeyId]);
+						
+				RTMPAddWcidAttributeEntry(pAd, BssIdx, pKeyInfo->KeyId, 
+							  pApCliEntry->SharedKey[pKeyInfo->KeyId].CipherAlg, 
+							  NULL);				
+										  
+				if (pMacEntry->AuthMode >= Ndis802_11AuthModeWPA)
+				{
+					/* set 802.1x port control */
+					pMacEntry->PortSecured = WPA_802_1X_PORT_SECURED;
+					pMacEntry->PrivacyFilter = Ndis802_11PrivFilterAcceptAll;
+				}
+			}
+		}	
+		else
+		{	
+			if(pMacEntry)
+			{
+				printk("APCLI: Set AES Security Set. [%d] (PAIRWISE) %d\n", BssIdx, pKeyInfo->KeyLen);
+				NdisZeroMemory(&pMacEntry->PairwiseKey, sizeof(CIPHER_KEY));  
+				pMacEntry->PairwiseKey.KeyLen = LEN_TK;
+				
+				NdisCopyMemory(&pMacEntry->PTK[OFFSET_OF_PTK_TK], pKeyInfo->KeyBuf, OFFSET_OF_PTK_TK);
+				NdisMoveMemory(pMacEntry->PairwiseKey.Key, &pMacEntry->PTK[OFFSET_OF_PTK_TK], pKeyInfo->KeyLen);
+				
+				pMacEntry->PairwiseKey.CipherAlg = CIPHER_AES;
+				
+				AsicAddPairwiseKeyEntry(pAd, (UCHAR)pMacEntry->Aid, &pMacEntry->PairwiseKey);
+				RTMPSetWcidSecurityInfo(pAd, BssIdx, 0, pMacEntry->PairwiseKey.CipherAlg, pMacEntry->Aid, PAIRWISEKEYTABLE);
+			}
+			else	
+			{
+				printk("APCLI: Set AES Security Set. (PAIRWISE) But pMacEntry NULL\n");
+			}			
+		}		
+	}
+}
+
+VOID CFG80211DRV_SetP2pCliAssocIe(VOID *pAdOrg, VOID *pData, UINT ie_len)
+{
+	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER)pAdOrg;
+	APCLI_STRUCT *apcli_entry;
+	hex_dump("P2PCLI=", pData, ie_len);
+
+	apcli_entry = &pAd->ApCfg.ApCliTab[MAIN_MBSSID];
+	
+	if (ie_len > 0)	
+	{
+		if (apcli_entry->wpa_supplicant_info.pWpaAssocIe)
+		{
+			os_free_mem(NULL, apcli_entry->wpa_supplicant_info.pWpaAssocIe);
+			apcli_entry->wpa_supplicant_info.pWpaAssocIe = NULL;
+		}
+
+		os_alloc_mem(NULL, (UCHAR **)&apcli_entry->wpa_supplicant_info.pWpaAssocIe, ie_len);
+		if (apcli_entry->wpa_supplicant_info.pWpaAssocIe)
+		{
+			apcli_entry->wpa_supplicant_info.WpaAssocIeLen = ie_len;
+			NdisMoveMemory(apcli_entry->wpa_supplicant_info.pWpaAssocIe, pData, apcli_entry->wpa_supplicant_info.WpaAssocIeLen);
+		}
+		else
+			apcli_entry->wpa_supplicant_info.WpaAssocIeLen = 0;
+	}
+	else
+	{
+		if (apcli_entry->wpa_supplicant_info.pWpaAssocIe)
+		{
+			os_free_mem(NULL, apcli_entry->wpa_supplicant_info.pWpaAssocIe);
+			apcli_entry->wpa_supplicant_info.pWpaAssocIe = NULL;
+		}
+		apcli_entry->wpa_supplicant_info.WpaAssocIeLen = 0;
+	}
+}
+
+/* For P2P_CLIENT Connection Setting in AP_CLI SM */
+BOOLEAN CFG80211DRV_P2pClientConnect(VOID *pAdOrg, VOID *pData)
+{
+	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER)pAdOrg;
+	CMD_RTPRIV_IOCTL_80211_CONNECT *pConnInfo;
+	UCHAR Connect_SSID[NDIS_802_11_LENGTH_SSID];
+	UINT32 Connect_SSIDLen;
+	
+	APCLI_STRUCT *apcli_entry;
+	apcli_entry = &pAd->ApCfg.ApCliTab[MAIN_MBSSID];
+	
+	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+	pObj->ioctl_if_type = INT_APCLI;
+	
+	pConnInfo = (CMD_RTPRIV_IOCTL_80211_CONNECT *)pData;
+	
+	DBGPRINT(RT_DEBUG_TRACE, ("APCLI Connection onGoing.....\n"));
+
+	Connect_SSIDLen = pConnInfo->SsidLen;
+	if (Connect_SSIDLen > NDIS_802_11_LENGTH_SSID)
+		Connect_SSIDLen = NDIS_802_11_LENGTH_SSID;
+	
+	memset(&Connect_SSID, 0, sizeof(Connect_SSID));
+	memcpy(Connect_SSID, pConnInfo->pSsid, Connect_SSIDLen);
+
+	apcli_entry->wpa_supplicant_info.WpaSupplicantUP = WPA_SUPPLICANT_ENABLE;
+
+	/* Check the connection is WPS or not */
+	if (pConnInfo->bWpsConnection) 
+	{
+		DBGPRINT(RT_DEBUG_TRACE, ("AP_CLI WPS Connection onGoing.....\n"));
+		apcli_entry->wpa_supplicant_info.WpaSupplicantUP |= WPA_SUPPLICANT_ENABLE_WPS;
+	}		
+
+	/* Set authentication mode */
+	if (pConnInfo->WpaVer == 2)
+	{
+		if (!pConnInfo->FlgIs8021x == TRUE) 
+		{
+			DBGPRINT(RT_DEBUG_TRACE,("APCLI WPA2PSK\n"));
+			Set_ApCli_AuthMode_Proc(pAd, "WPA2PSK");
+		}
+	}
+	else if (pConnInfo->WpaVer == 1)
+	{
+		if (!pConnInfo->FlgIs8021x) 
+		{
+			DBGPRINT(RT_DEBUG_TRACE,("APCLI WPAPSK\n"));
+			Set_ApCli_AuthMode_Proc(pAd, "WPAPSK");
+		}
+	}
+	else
+		Set_ApCli_AuthMode_Proc(pAd, "OPEN");	
+
+	/* Set PTK Encryption Mode */
+	if (pConnInfo->PairwiseEncrypType & RT_CMD_80211_CONN_ENCRYPT_CCMP) {
+		DBGPRINT(RT_DEBUG_TRACE,("AES\n"));
+		Set_ApCli_EncrypType_Proc(pAd, "AES");
+	}
+	else if (pConnInfo->PairwiseEncrypType & RT_CMD_80211_CONN_ENCRYPT_TKIP) {
+		DBGPRINT(RT_DEBUG_TRACE,("TKIP\n"));
+		Set_ApCli_EncrypType_Proc(pAd, "TKIP");
+	}
+	else if (pConnInfo->PairwiseEncrypType & RT_CMD_80211_CONN_ENCRYPT_WEP)
+	{
+		DBGPRINT(RT_DEBUG_TRACE,("WEP\n"));
+		Set_ApCli_EncrypType_Proc(pAd, "WEP");
+	}
+	
+	
+	if (pConnInfo->pBssid != NULL)
+	{
+		NdisZeroMemory(apcli_entry->CfgApCliBssid, MAC_ADDR_LEN);
+		NdisCopyMemory(apcli_entry->CfgApCliBssid, pConnInfo->pBssid, MAC_ADDR_LEN);
+	}
+	
+	OPSTATUS_SET_FLAG(pAd, fOP_AP_STATUS_MEDIA_STATE_CONNECTED);
+
+	pAd->cfg80211_ctrl.FlgCfg80211Connecting = TRUE;
+	Set_ApCli_Ssid_Proc(pAd, (PSTRING)Connect_SSID);
+	Set_ApCli_Enable_Proc(pAd, "1");
+	CFG80211DBG(RT_DEBUG_OFF, ("80211> APCLI CONNECTING SSID = %s\n", Connect_SSID));
+
+	return TRUE;	
+}
+
+VOID CFG80211_P2pClientConnectResultInform(
+	VOID *pAdCB, UCHAR *pBSSID,
+        UCHAR *pReqIe, UINT32 ReqIeLen,
+        UCHAR *pRspIe, UINT32 RspIeLen,
+        UCHAR FlgIsSuccess)
+{
+	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER)pAdCB;
+
+	CFG80211OS_P2pClientConnectResultInform(pAd->ApCfg.ApCliTab[MAIN_MBSSID].wdev.if_dev, pBSSID, 
+					pReqIe, ReqIeLen, pRspIe, RspIeLen, FlgIsSuccess);
+
+	pAd->cfg80211_ctrl.FlgCfg80211Connecting = FALSE;
+}
+
+VOID CFG80211_LostP2pGoInform(VOID *pAdCB)
+{
+	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER)pAdCB;
+	CFG80211_CB *p80211CB = pAd->pCfg80211_CB;
+	PNET_DEV pNetDev = NULL;
+	
+	DBGPRINT(RT_DEBUG_TRACE, ("80211> CFG80211_LostGoInform ==> \n"));
+
+	pAd->cfg80211_ctrl.FlgCfg80211Connecting = FALSE;
+	if ((pAd->cfg80211_ctrl.Cfg80211VifDevSet.vifDevList.size > 0) &&        
+	((pNetDev = RTMP_CFG80211_FindVifEntry_ByType(pAd, RT_CMD_80211_IFTYPE_P2P_CLIENT)) != NULL))
+	{
+	        if (pNetDev->ieee80211_ptr->sme_state == CFG80211_SME_CONNECTING)
+       	 	{
+                   cfg80211_connect_result(pNetDev, NULL, NULL, 0, NULL, 0,
+                                                                   WLAN_STATUS_UNSPECIFIED_FAILURE, GFP_KERNEL);
+        	}
+        	else if (pNetDev->ieee80211_ptr->sme_state == CFG80211_SME_CONNECTED)
+        	{
+                   cfg80211_disconnected(pNetDev, 0, NULL, 0, GFP_KERNEL);
+        	}
+	}
+	else
+		DBGPRINT(RT_DEBUG_ERROR, ("80211> BUG CFG80211_LostGoInform, BUT NetDevice not exist.\n"));
+		
+	Set_ApCli_Enable_Proc(pAd, "0");	
+}
+#endif /* RT_CFG80211_P2P_CONCURRENT_DEVICE */
+#endif /* RT_CFG80211_P2P_SUPPORT */
+#endif /* RT_CFG80211_SUPPORT */
 
diff --git a/package/feeds/custom/mt7615d/src/mt_wifi_ap/Makefile b/package/feeds/custom/mt7615d/src/mt_wifi_ap/Makefile
index 2a1578ff488..2ec14092023 100644
--- a/package/feeds/custom/mt7615d/src/mt_wifi_ap/Makefile
+++ b/package/feeds/custom/mt7615d/src/mt_wifi_ap/Makefile
@@ -8,7 +8,7 @@ WIFI_DRV_PATH = drivers/net/wireless/mtk/mt7615e
 endif
 endif
 
-EXTRA_CFLAGS = -I$(WIFI_DRV_PATH)/mt_wifi/include \
+EXTRA_CFLAGS += -I$(WIFI_DRV_PATH)/mt_wifi/include \
 				-I$(WIFI_DRV_PATH)/mt_wifi/embedded/include \
 				-I$(WIFI_DRV_PATH)/mt_wifi/ate/include \
 				-I$(WIFI_DRV_PATH)/mt_wifi/include/mcu
@@ -487,7 +487,7 @@ ifeq ($(CONFIG_HOSTAPD_MAP_SUPPORT),y)
 endif
 
 #ENTERPRISE_AP
-ifeq ($(CONFIG_ENTERPRISE_AP_SUPPORT),y)
+ifneq ($(CONFIG_HOSTAPD_MAP_SUPPORT),y)
 	EXTRA_CFLAGS += -DHOSTAPD_11R_SUPPORT
 	EXTRA_CFLAGS += -DMBSS_DTIM_SUPPORT
 	ifeq ($(CONFIG_VLAN_SUPPORT),y)
@@ -803,7 +803,7 @@ ifeq ($(CONFIG_AIR_MONITOR),y)
 endif
 
 ifeq ($(CONFIG_EASY_SETUP_SUPPORT),y)
-$(DRV_NAME)-objs += $(SRC_EMBEDDED_DIR)/easy_setup/ez_cmm.o
+$(DRV_NAME)-y += $(SRC_EMBEDDED_DIR)/easy_setup/ez_cmm.o
 endif
 
 ifeq ($(CONFIG_MWDS),y)
@@ -1297,23 +1297,23 @@ endif
 # Root
 #
 
-$(DRV_NAME)-objs += $(ap_objs) $(cmm_objs) $(asic_objs) $(chip_objs) $(rate_objs)\
+$(DRV_NAME)-y += $(ap_objs) $(cmm_objs) $(asic_objs) $(chip_objs) $(rate_objs)\
                     $(spec_objs) $(func_objs) $(os_objs) $(dot11_ft_objs)
 
-$(DRV_NAME)-objs += $(SRC_EMBEDDED_DIR)/common/eeprom.o\
+$(DRV_NAME)-y += $(SRC_EMBEDDED_DIR)/common/eeprom.o\
 					$(SRC_EMBEDDED_DIR)/common/ee_flash.o\
 					$(SRC_EMBEDDED_DIR)/common/ee_efuse.o
 
-$(DRV_NAME)-objs += $(SRC_EMBEDDED_DIR)/common/cmm_mac_pci.o
-$(DRV_NAME)-objs += $(SRC_EMBEDDED_DIR)/common/hif_pci.o
+$(DRV_NAME)-y += $(SRC_EMBEDDED_DIR)/common/cmm_mac_pci.o
+$(DRV_NAME)-y += $(SRC_EMBEDDED_DIR)/common/hif_pci.o
 
-$(DRV_NAME)-objs += $(SRC_DIR)/os/linux/rt_pci_rbus.o\
+$(DRV_NAME)-y += $(SRC_DIR)/os/linux/rt_pci_rbus.o\
                     $(SRC_DIR)/os/linux/rt_rbus_pci_drv.o\
                     $(SRC_DIR)/os/linux/rt_rbus_pci_util.o\
                     #$(SRC_DIR)/os/linux/rbus_main_dev.o
 
 ifeq ($(CONFIG_ATE_SUPPORT),y)
-$(DRV_NAME)-objs += $(SRC_DIR)/ate/ate_agent.o\
+$(DRV_NAME)-y += $(SRC_DIR)/ate/ate_agent.o\
                     $(SRC_DIR)/ate/testmode_ioctl.o\
 		    $(SRC_DIR)/ate/mt_mac/mt_testmode.o\
  		    $(SRC_DIR)/ate/LoopBack.o
@@ -1321,7 +1321,7 @@ endif
 
 
 ifeq ($(CONFIG_TCP_RACK_SUPPORT),y)
-$(DRV_NAME)-objs += $(SRC_EMBEDDED_DIR)/common/cmm_tcprack.o
+$(DRV_NAME)-y += $(SRC_EMBEDDED_DIR)/common/cmm_tcprack.o
 endif
 
 ifeq ($(CONFIG_LED_CONTROL_SUPPORT),y)
@@ -1433,4 +1433,6 @@ endif
 
 MODULE_FLAGS=$(EXTRA_CFLAGS)
 export MODULE_FLAGS
+ifeq ($(CONFIG_WHNAT_SUPPORT),y)
 obj-m+=$(SRC_EMBEDDED_DIR)/plug_in/
+endif
diff --git a/package/feeds/custom/mt7615d/src/wlan_cfg/mt7622/Readme.txt b/package/feeds/custom/mt7615d/src/wlan_cfg/mt7622/Readme.txt
index 23f9fb46c9a..8ae9c111858 100644
--- a/package/feeds/custom/mt7615d/src/wlan_cfg/mt7622/Readme.txt
+++ b/package/feeds/custom/mt7615d/src/wlan_cfg/mt7622/Readme.txt
@@ -13,6 +13,6 @@ iNIC_ap.dat
 	For configuration of 1st 7615 chip. Refer to /etc/wireless/l1profile.dat,
         it should be generated at /etc/Wireless/iNIC/iNIC_ap.dat due to INDEX1_profile_path.
 
-mt7615_3.da
+mt7615_3.dat
 	For configuration of 2nd 7615 chip. Refer to /etc/wireless/l1profile.dat,
         it should be generated at /etc/wireless/mt7615/mt7615_3.dat due to INDEX2_profile_path.
diff --git a/package/network/utils/iwinfo/Makefile b/package/network/utils/iwinfo/Makefile
index fd2d836bdb3..46100efc037 100644
--- a/package/network/utils/iwinfo/Makefile
+++ b/package/network/utils/iwinfo/Makefile
@@ -75,6 +75,7 @@ IWINFO_BACKENDS := \
 	$(if $(CONFIG_PACKAGE_kmod-brcm-wl),wl) \
 	$(if $(CONFIG_PACKAGE_kmod-brcm-wl-mini),wl) \
 	$(if $(CONFIG_PACKAGE_kmod-brcm-wl-mimo),wl) \
+	$(if $(CONFIG_PACKAGE_kmod-mt7615d),ra) \
 	$(if $(CONFIG_PACKAGE_kmod-cfg80211),nl80211)
 
 TARGET_CFLAGS += \
diff --git a/package/network/utils/iwinfo/patches/001-ralink.patch b/package/network/utils/iwinfo/patches/001-ralink.patch
new file mode 100644
index 00000000000..995066f67c8
--- /dev/null
+++ b/package/network/utils/iwinfo/patches/001-ralink.patch
@@ -0,0 +1,1546 @@
+--- /dev/null
++++ b/api/ralink.h
+@@ -0,0 +1,205 @@
++#ifndef _RALINK_H
++#define _RALINK_H
++
++#define MAX_NUMBER_OF_MAC		    64
++
++#define MODE_CCK		0
++#define MODE_OFDM		1
++#define MODE_HTMIX		2
++#define MODE_HTGREENFIELD	3
++
++#define BW_20			0
++#define BW_40			1
++#define BW_BOTH			2
++#define BW_10			3
++
++#define 		MAC_ADDR_LEN 6
++#define 		ETH_LENGTH_OF_ADDRESS 6
++#define 		MAX_LEN_OF_MAC_TABLE 64
++
++#define RT_PRIV_IOCTL				(SIOCIWFIRSTPRIV + 0x01)
++#define RTPRIV_IOCTL_SET			(SIOCIWFIRSTPRIV + 0x02)
++
++#define RTPRIV_IOCTL_BBP			(SIOCIWFIRSTPRIV + 0x03)
++#define RTPRIV_IOCTL_MAC			(SIOCIWFIRSTPRIV + 0x05)
++#define RTPRIV_IOCTL_E2P			(SIOCIWFIRSTPRIV + 0x07)
++
++#define RTPRIV_IOCTL_STATISTICS				(SIOCIWFIRSTPRIV + 0x09)
++#define RTPRIV_IOCTL_ADD_PMKID_CACHE		(SIOCIWFIRSTPRIV + 0x0A)
++#define RTPRIV_IOCTL_RADIUS_DATA			(SIOCIWFIRSTPRIV + 0x0C)
++#define RTPRIV_IOCTL_GSITESURVEY			(SIOCIWFIRSTPRIV + 0x0D)
++#define RTPRIV_IOCTL_ADD_WPA_KEY			(SIOCIWFIRSTPRIV + 0x0E)
++#define RTPRIV_IOCTL_GET_MAC_TABLE			(SIOCIWFIRSTPRIV + 0x0F)
++#define RTPRIV_IOCTL_GET_MAC_TABLE_STRUCT	(SIOCIWFIRSTPRIV + 0x1F)
++#define RTPRIV_IOCTL_STATIC_WEP_COPY		(SIOCIWFIRSTPRIV + 0x10)
++#define RTPRIV_IOCTL_WSC_PROFILE			(SIOCIWFIRSTPRIV + 0x12)
++#define	RTPRIV_IOCTL_GSTAINFO				(SIOCIWFIRSTPRIV + 0x1A)
++#define	RTPRIV_IOCTL_GSTAT					(SIOCIWFIRSTPRIV + 0x1B)
++#define RTPRIV_IOCTL_GRSSI					(SIOCIWFIRSTPRIV + 0x1C)
++#define RTPRIV_IOCTL_GTXBFCALP				(SIOCIWFIRSTPRIV + 0x1D)
++
++#define RT_QUERY_ATE_TXDONE_COUNT			0x0401
++#define OID_GET_SET_TOGGLE					0x8000
++
++#define OID_802_11_NETWORK_TYPES_SUPPORTED          0x0103
++#define OID_802_11_NETWORK_TYPE_IN_USE		   0x0104
++#define OID_802_11_RSSI_TRIGGER		          0x0107
++#define RT_OID_802_11_RSSI							0x0108 //rt2860 only , kathy
++#define RT_OID_802_11_RSSI_1						0x0109 //rt2860 only , kathy
++#define RT_OID_802_11_RSSI_2						0x010A //rt2860 only , kathy
++#define OID_802_11_NUMBER_OF_ANTENNAS		    0x010B
++#define OID_802_11_RX_ANTENNA_SELECTED		   0x010C
++#define OID_802_11_TX_ANTENNA_SELECTED		   0x010D
++#define OID_802_11_SUPPORTED_RATES		       0x010E
++#define OID_802_11_ADD_WEP				    0x0112
++#define OID_802_11_REMOVE_WEP				 0x0113
++#define OID_802_11_DISASSOCIATE		          0x0114
++#define OID_802_11_PRIVACY_FILTER		        0x0118
++#define OID_802_11_ASSOCIATION_INFORMATION          0x011E
++#define OID_802_11_TEST				       0x011F
++#define RT_OID_802_11_COUNTRY_REGION		     0x0507
++#define OID_802_11_BSSID_LIST_SCAN		       0x0508
++#define OID_802_11_SSID				       0x0509
++#define OID_802_11_BSSID				      0x050A
++#define RT_OID_802_11_RADIO				   0x050B
++#define RT_OID_802_11_PHY_MODE				0x050C
++#define RT_OID_802_11_STA_CONFIG		         0x050D
++#define OID_802_11_DESIRED_RATES		         0x050E
++#define RT_OID_802_11_PREAMBLE				0x050F
++#define OID_802_11_WEP_STATUS				 0x0510
++#define OID_802_11_AUTHENTICATION_MODE		   0x0511
++#define OID_802_11_INFRASTRUCTURE_MODE		   0x0512
++#define RT_OID_802_11_RESET_COUNTERS		     0x0513
++#define OID_802_11_RTS_THRESHOLD		         0x0514
++#define OID_802_11_FRAGMENTATION_THRESHOLD          0x0515
++#define OID_802_11_POWER_MODE				 0x0516
++#define OID_802_11_TX_POWER_LEVEL		        0x0517
++#define RT_OID_802_11_ADD_WPA				 0x0518
++#define OID_802_11_REMOVE_KEY				 0x0519
++#define OID_802_11_ADD_KEY				    0x0520
++#define OID_802_11_CONFIGURATION		         0x0521
++#define OID_802_11_TX_PACKET_BURST					0x0522
++#define RT_OID_802_11_QUERY_NOISE_LEVEL		  0x0523
++#define RT_OID_802_11_EXTRA_INFO		         0x0524
++#define RT_OID_802_11_HARDWARE_REGISTER		  0x0525
++#define OID_802_11_ENCRYPTION_STATUS		     OID_802_11_WEP_STATUS
++
++#define RT_OID_DEVICE_NAME				    0x0607
++#define RT_OID_VERSION_INFO				   0x0608
++#define OID_802_11_BSSID_LIST				 0x0609
++#define OID_802_3_CURRENT_ADDRESS		        0x060A
++#define OID_GEN_MEDIA_CONNECT_STATUS		     0x060B
++#define RT_OID_802_11_QUERY_LINK_STATUS		  0x060C
++#define OID_802_11_RSSI				       0x060D
++#define OID_802_11_STATISTICS				 0x060E
++#define OID_GEN_RCV_OK				        0x060F
++#define OID_GEN_RCV_NO_BUFFER				 0x0610
++#define RT_OID_802_11_QUERY_EEPROM_VERSION          0x0611
++#define RT_OID_802_11_QUERY_FIRMWARE_VERSION        0x0612
++#define RT_OID_802_11_QUERY_LAST_RX_RATE		 0x0613
++#define RT_OID_802_11_TX_POWER_LEVEL_1		   0x0614
++#define RT_OID_802_11_QUERY_PIDVID		       0x0615
++
++//#if WPA_SUPPLICANT_SUPPORT
++#define OID_SET_COUNTERMEASURES		          0x0616
++#define OID_802_11_SET_IEEE8021X		         0x0617
++#define OID_802_11_SET_IEEE8021X_REQUIRE_KEY        0x0618
++#define OID_802_11_PMKID				      0x0620
++#define RT_OID_WPA_SUPPLICANT_SUPPORT					0x0621
++#define RT_OID_WE_VERSION_COMPILED		       0x0622
++//#endif
++
++//rt2860 , kathy
++#define	RT_OID_802_11_SNR_0							0x0630
++#define	RT_OID_802_11_SNR_1							0x0631
++#define	RT_OID_802_11_QUERY_LAST_TX_RATE			0x0632
++#define	RT_OID_802_11_QUERY_HT_PHYMODE				0x0633
++#define	RT_OID_802_11_SET_HT_PHYMODE				0x0634
++#define	OID_802_11_RELOAD_DEFAULTS					0x0635
++#define	RT_OID_802_11_QUERY_APSD_SETTING			0x0636
++#define	RT_OID_802_11_SET_APSD_SETTING				0x0637
++#define	RT_OID_802_11_QUERY_APSD_PSM				0x0638
++#define	RT_OID_802_11_SET_APSD_PSM					0x0639
++#define	RT_OID_802_11_QUERY_DLS						0x063A
++#define	RT_OID_802_11_SET_DLS						0x063B
++#define	RT_OID_802_11_QUERY_DLS_PARAM				0x063C
++#define	RT_OID_802_11_SET_DLS_PARAM					0x063D
++#define RT_OID_802_11_QUERY_WMM		   		0x063E
++#define RT_OID_802_11_SET_WMM      					0x063F
++#define RT_OID_802_11_QUERY_IMME_BA_CAP				0x0640
++#define RT_OID_802_11_SET_IMME_BA_CAP				0x0641
++#define RT_OID_802_11_QUERY_BATABLE					0x0642
++#define RT_OID_802_11_ADD_IMME_BA					0x0643
++#define RT_OID_802_11_TEAR_IMME_BA					0x0644
++#define RT_OID_DRIVER_DEVICE_NAME		        0x0645
++#define RT_OID_802_11_QUERY_DAT_HT_PHYMODE          0x0646
++#define RT_OID_QUERY_MULTIPLE_CARD_SUPPORT          0x0647
++#define OID_802_11_SET_PSPXLINK_MODE				0x0648
++#define OID_802_11_SET_PASSPHRASE					0x0649
++#define RT_OID_802_11_SNR_2							0x064a
++#define RT_OID_802_11_STREAM_SNR					0x064b
++#define RT_OID_802_11_QUERY_TXBF_TABLE				0x0650
++#define RT_OID_802_11_WSC_QUERY_PROFILE				0x0750
++#define RT_OID_WSC_UUID				       0x0753
++
++
++#define RT_OID_802_11_BSSID		        (OID_GET_SET_TOGGLE | OID_802_11_BSSID)
++#define RT_OID_802_11_SSID		         (OID_GET_SET_TOGGLE | OID_802_11_SSID)
++#define RT_OID_802_11_INFRASTRUCTURE_MODE     (OID_GET_SET_TOGGLE | OID_802_11_INFRASTRUCTURE_MODE)
++#define RT_OID_802_11_ADD_WEP		      (OID_GET_SET_TOGGLE | OID_802_11_ADD_WEP)
++#define RT_OID_802_11_ADD_KEY		      (OID_GET_SET_TOGGLE | OID_802_11_ADD_KEY)
++#define RT_OID_802_11_REMOVE_WEP		   (OID_GET_SET_TOGGLE | OID_802_11_REMOVE_WEP)
++#define RT_OID_802_11_REMOVE_KEY		   (OID_GET_SET_TOGGLE | OID_802_11_REMOVE_KEY)
++#define RT_OID_802_11_DISASSOCIATE		 (OID_GET_SET_TOGGLE | OID_802_11_DISASSOCIATE)
++#define RT_OID_802_11_AUTHENTICATION_MODE     (OID_GET_SET_TOGGLE | OID_802_11_AUTHENTICATION_MODE)
++#define RT_OID_802_11_PRIVACY_FILTER          (OID_GET_SET_TOGGLE | OID_802_11_PRIVACY_FILTER)
++#define RT_OID_802_11_BSSID_LIST_SCAN         (OID_GET_SET_TOGGLE | OID_802_11_BSSID_LIST_SCAN)
++#define RT_OID_802_11_WEP_STATUS		   (OID_GET_SET_TOGGLE | OID_802_11_WEP_STATUS)
++#define RT_OID_802_11_RELOAD_DEFAULTS         (OID_GET_SET_TOGGLE | OID_802_11_RELOAD_DEFAULTS)
++#define RT_OID_802_11_NETWORK_TYPE_IN_USE     (OID_GET_SET_TOGGLE | OID_802_11_NETWORK_TYPE_IN_USE)
++#define RT_OID_802_11_TX_POWER_LEVEL          (OID_GET_SET_TOGGLE | OID_802_11_TX_POWER_LEVEL)
++#define RT_OID_802_11_RSSI_TRIGGER		 (OID_GET_SET_TOGGLE | OID_802_11_RSSI_TRIGGER)
++#define RT_OID_802_11_FRAGMENTATION_THRESHOLD (OID_GET_SET_TOGGLE | OID_802_11_FRAGMENTATION_THRESHOLD)
++#define RT_OID_802_11_RTS_THRESHOLD		(OID_GET_SET_TOGGLE | OID_802_11_RTS_THRESHOLD)
++#define RT_OID_802_11_RX_ANTENNA_SELECTED     (OID_GET_SET_TOGGLE | OID_802_11_RX_ANTENNA_SELECTED)
++#define RT_OID_802_11_TX_ANTENNA_SELECTED     (OID_GET_SET_TOGGLE | OID_802_11_TX_ANTENNA_SELECTED)
++#define RT_OID_802_11_SUPPORTED_RATES         (OID_GET_SET_TOGGLE | OID_802_11_SUPPORTED_RATES)
++#define RT_OID_802_11_DESIRED_RATES		(OID_GET_SET_TOGGLE | OID_802_11_DESIRED_RATES)
++#define RT_OID_802_11_CONFIGURATION		(OID_GET_SET_TOGGLE | OID_802_11_CONFIGURATION)
++#define RT_OID_802_11_POWER_MODE		   (OID_GET_SET_TOGGLE | OID_802_11_POWER_MODE)
++
++typedef union _MACHTTRANSMIT_SETTING {
++	struct  {
++		unsigned short	MCS:7;  // MCS
++		unsigned short	BW:1;   //channel bandwidth 20MHz or 40 MHz
++		unsigned short	ShortGI:1;
++		unsigned short	STBC:2; //SPACE
++		unsigned short	rsv:3;
++		unsigned short	MODE:2; // Use definition MODE_xxx.
++	} field;
++	unsigned short	word;
++} MACHTTRANSMIT_SETTING;
++
++typedef struct _RT_802_11_MAC_ENTRY {
++	unsigned char		ApIdx;
++	unsigned char		Addr[6];
++	unsigned char		Aid;
++	unsigned char		Psm;     // 0:PWR_ACTIVE, 1:PWR_SAVE
++	unsigned char		MimoPs;  // 0:MMPS_STATIC, 1:MMPS_DYNAMIC, 3:MMPS_Enabled
++	char			AvgRssi0;
++	char			AvgRssi1;
++	char			AvgRssi2;
++	unsigned int		ConnectedTime;
++	MACHTTRANSMIT_SETTING	TxRate;
++	unsigned int		LastRxRate;
++
++	short			StreamSnr[3];
++	short			SoundingRespSnr[3];
++} RT_802_11_MAC_ENTRY;
++
++typedef struct _RT_802_11_MAC_TABLE {
++	unsigned long		Num;
++	RT_802_11_MAC_ENTRY	Entry[64]; //MAX_LEN_OF_MAC_TABLE = 64
++} RT_802_11_MAC_TABLE;
++
++#endif
+--- a/include/iwinfo/lua.h
++++ b/include/iwinfo/lua.h
+@@ -37,6 +37,10 @@
+ #define IWINFO_MADWIFI_META	"iwinfo.madwifi"
+ #endif
+ 
++#ifdef USE_RA
++#define IWINFO_RA_META     "iwinfo.ra"
++#endif
++
+ #ifdef USE_NL80211
+ #define IWINFO_NL80211_META	"iwinfo.nl80211"
+ #endif
+--- a/include/iwinfo.h
++++ b/include/iwinfo.h
+@@ -259,6 +259,7 @@ extern const struct iwinfo_ops wext_ops;
+ extern const struct iwinfo_ops madwifi_ops;
+ extern const struct iwinfo_ops nl80211_ops;
+ extern const struct iwinfo_ops wl_ops;
++extern const struct iwinfo_ops ra_ops;
+ 
+ #include "iwinfo/utils.h"
+ 
+--- a/iwinfo_lib.c
++++ b/iwinfo_lib.c
+@@ -334,6 +334,9 @@ static const struct iwinfo_ops *backends
+ #ifdef USE_WL
+ 	&wl_ops,
+ #endif
++#ifdef USE_RA
++	&ra_ops,
++#endif
+ 	&wext_ops,
+ };
+ 
+--- a/iwinfo_lua.c
++++ b/iwinfo_lua.c
+@@ -659,6 +659,35 @@ static int iwinfo_L_countrylist(lua_Stat
+ 	return 1;
+ }
+ 
++#ifdef USE_RA
++/* Ralink */
++LUA_WRAP_INT_OP(ra,channel)
++LUA_WRAP_INT_OP(ra,frequency)
++LUA_WRAP_INT_OP(ra,frequency_offset)
++LUA_WRAP_INT_OP(ra,txpower)
++LUA_WRAP_INT_OP(ra,txpower_offset)
++LUA_WRAP_INT_OP(ra,bitrate)
++LUA_WRAP_INT_OP(ra,signal)
++LUA_WRAP_INT_OP(ra,noise)
++LUA_WRAP_INT_OP(ra,quality)
++LUA_WRAP_INT_OP(ra,quality_max)
++LUA_WRAP_STRING_OP(ra,ssid)
++LUA_WRAP_STRING_OP(ra,bssid)
++LUA_WRAP_STRING_OP(ra,country)
++LUA_WRAP_STRING_OP(ra,hardware_name)
++LUA_WRAP_STRING_OP(ra,phyname)
++LUA_WRAP_STRUCT_OP(ra,mode)
++LUA_WRAP_STRUCT_OP(ra,assoclist)
++LUA_WRAP_STRUCT_OP(ra,txpwrlist)
++LUA_WRAP_STRUCT_OP(ra,scanlist)
++LUA_WRAP_STRUCT_OP(ra,freqlist)
++LUA_WRAP_STRUCT_OP(ra,countrylist)
++LUA_WRAP_STRUCT_OP(ra,hwmodelist)
++LUA_WRAP_STRUCT_OP(ra,htmodelist)
++LUA_WRAP_STRUCT_OP(ra,encryption)
++LUA_WRAP_STRUCT_OP(ra,mbssid_support)
++LUA_WRAP_STRUCT_OP(ra,hardware_id)
++#endif
+ 
+ #ifdef USE_WL
+ /* Broadcom */
+@@ -908,6 +937,41 @@ static const luaL_reg R_wext[] = {
+ 	{ NULL, NULL }
+ };
+ 
++#ifdef USE_RA
++/* Ralink table */
++static const luaL_reg R_ra[] = {
++   LUA_REG(ra,channel),
++   LUA_REG(ra,frequency),
++   LUA_REG(ra,frequency_offset),
++   LUA_REG(ra,txpower),
++   LUA_REG(ra,txpower_offset),
++   LUA_REG(ra,bitrate),
++   LUA_REG(ra,signal),
++   LUA_REG(ra,noise),
++   LUA_REG(ra,quality),
++   LUA_REG(ra,quality_max),
++   LUA_REG(ra,mode),
++   LUA_REG(ra,ssid),
++   LUA_REG(ra,bssid),
++   LUA_REG(ra,country),
++   LUA_REG(ra,assoclist),
++   LUA_REG(ra,txpwrlist),
++   LUA_REG(ra,scanlist),
++   LUA_REG(ra,freqlist),
++   LUA_REG(ra,countrylist),
++   LUA_REG(ra,hwmodelist),
++   LUA_REG(ra,htmodelist),
++   LUA_REG(ra,encryption),
++   LUA_REG(ra,mbssid_support),
++   LUA_REG(ra,hardware_id),
++   LUA_REG(ra,hardware_name),
++   LUA_REG(ra,phyname),
++   { NULL, NULL }
++};
++
++#endif
++
++
+ /* Common */
+ static const luaL_reg R_common[] = {
+ 	{ "type", iwinfo_L_type },
+@@ -919,6 +983,15 @@ static const luaL_reg R_common[] = {
+ LUALIB_API int luaopen_iwinfo(lua_State *L) {
+ 	luaL_register(L, IWINFO_META, R_common);
+ 
++
++#ifdef USE_RA
++   luaL_newmetatable(L, IWINFO_RA_META);
++   luaL_register(L, NULL, R_ra);
++   lua_pushvalue(L, -1);
++   lua_setfield(L, -2, "__index");
++   lua_setfield(L, -2, "ra");
++#endif
++
+ #ifdef USE_WL
+ 	luaL_newmetatable(L, IWINFO_WL_META);
+ 	luaL_register(L, NULL, R_common);
+--- /dev/null
++++ b/iwinfo_ra.c
+@@ -0,0 +1,1025 @@
++#include "iwinfo.h"
++#include "iwinfo_ra.h"
++#include "iwinfo_wext.h"
++
++#define MIDFIX5G "x"
++
++/*
++ * Ralink ISO 3166 to Country/Region Code mapping.
++ */
++
++static struct ISO3166_to_CCode
++{
++	u_int16_t iso3166;
++	u_int16_t ccode;
++} CountryCodes[] =
++    {
++	{0x3030 /* 00 */, 0},	/* World */
++	{0x4145 /* AE */, 784}, /* U.A.E. */
++	{0x414C /* AL */, 8},	/* Albania */
++	{0x414D /* AM */, 51},	/* Armenia */
++	{0x4152 /* AR */, 32},	/* Argentina */
++	{0x4154 /* AT */, 40},	/* Austria */
++	{0x4155 /* AU */, 36},	/* Australia */
++	{0x415A /* AZ */, 31},	/* Azerbaijan */
++	{0x4245 /* BE */, 56},	/* Belgium */
++	{0x4247 /* BG */, 100}, /* Bulgaria */
++	{0x4248 /* BH */, 48},	/* Bahrain */
++	{0x424E /* BN */, 96},	/* Brunei Darussalam */
++	{0x424F /* BO */, 68},	/* Bolivia */
++	{0x4252 /* BR */, 76},	/* Brazil */
++	{0x4259 /* BY */, 112}, /* Belarus */
++	{0x425A /* BZ */, 84},	/* Belize */
++	{0x4341 /* CA */, 124}, /* Canada */
++	{0x4348 /* CH */, 756}, /* Switzerland */
++	{0x434C /* CL */, 152}, /* Chile */
++	{0x434E /* CN */, 156}, /* People's Republic of China */
++	{0x434F /* CO */, 170}, /* Colombia */
++	{0x4352 /* CR */, 188}, /* Costa Rica */
++	{0x4359 /* CY */, 196}, /* Cyprus */
++	{0x435A /* CZ */, 203}, /* Czech Republic */
++	{0x4445 /* DE */, 276}, /* Germany */
++	{0x444B /* DK */, 208}, /* Denmark */
++	{0x444F /* DO */, 214}, /* Dominican Republic */
++	{0x445A /* DZ */, 12},	/* Algeria */
++	{0x4543 /* EC */, 218}, /* Ecuador */
++	{0x4545 /* EE */, 233}, /* Estonia */
++	{0x4547 /* EG */, 818}, /* Egypt */
++	{0x4553 /* ES */, 724}, /* Spain */
++	{0x4649 /* FI */, 246}, /* Finland */
++	{0x464F /* FO */, 234}, /* Faeroe Islands */
++	{0x4652 /* FR */, 250}, /* France */
++	{0x4652 /* FR */, 255}, /* France2 */
++	{0x4742 /* GB */, 826}, /* United Kingdom */
++	{0x4745 /* GE */, 268}, /* Georgia */
++	{0x4752 /* GR */, 300}, /* Greece */
++	{0x4754 /* GT */, 320}, /* Guatemala */
++	{0x484B /* HK */, 344}, /* Hong Kong S.A.R., P.R.C. */
++	{0x484E /* HN */, 340}, /* Honduras */
++	{0x4852 /* HR */, 191}, /* Croatia */
++	{0x4855 /* HU */, 348}, /* Hungary */
++	{0x4944 /* ID */, 360}, /* Indonesia */
++	{0x4945 /* IE */, 372}, /* Ireland */
++	{0x494C /* IL */, 376}, /* Israel */
++	{0x494E /* IN */, 356}, /* India */
++	{0x4951 /* IQ */, 368}, /* Iraq */
++	{0x4952 /* IR */, 364}, /* Iran */
++	{0x4953 /* IS */, 352}, /* Iceland */
++	{0x4954 /* IT */, 380}, /* Italy */
++	{0x4A4D /* JM */, 388}, /* Jamaica */
++	{0x4A4F /* JO */, 400}, /* Jordan */
++	{0x4A50 /* JP */, 392}, /* Japan */
++	{0x4A50 /* JP */, 393}, /* Japan (JP1) */
++	{0x4A50 /* JP */, 394}, /* Japan (JP0) */
++	{0x4A50 /* JP */, 395}, /* Japan (JP1-1) */
++	{0x4A50 /* JP */, 396}, /* Japan (JE1) */
++	{0x4A50 /* JP */, 397}, /* Japan (JE2) */
++	{0x4A50 /* JP */, 399}, /* Japan (JP6) */
++	{0x4A50 /* JP */, 900}, /* Japan */
++	{0x4A50 /* JP */, 901}, /* Japan */
++	{0x4A50 /* JP */, 902}, /* Japan */
++	{0x4A50 /* JP */, 903}, /* Japan */
++	{0x4A50 /* JP */, 904}, /* Japan */
++	{0x4A50 /* JP */, 905}, /* Japan */
++	{0x4A50 /* JP */, 906}, /* Japan */
++	{0x4A50 /* JP */, 907}, /* Japan */
++	{0x4A50 /* JP */, 908}, /* Japan */
++	{0x4A50 /* JP */, 909}, /* Japan */
++	{0x4A50 /* JP */, 910}, /* Japan */
++	{0x4A50 /* JP */, 911}, /* Japan */
++	{0x4A50 /* JP */, 912}, /* Japan */
++	{0x4A50 /* JP */, 913}, /* Japan */
++	{0x4A50 /* JP */, 914}, /* Japan */
++	{0x4A50 /* JP */, 915}, /* Japan */
++	{0x4A50 /* JP */, 916}, /* Japan */
++	{0x4A50 /* JP */, 917}, /* Japan */
++	{0x4A50 /* JP */, 918}, /* Japan */
++	{0x4A50 /* JP */, 919}, /* Japan */
++	{0x4A50 /* JP */, 920}, /* Japan */
++	{0x4A50 /* JP */, 921}, /* Japan */
++	{0x4A50 /* JP */, 922}, /* Japan */
++	{0x4A50 /* JP */, 923}, /* Japan */
++	{0x4A50 /* JP */, 924}, /* Japan */
++	{0x4A50 /* JP */, 925}, /* Japan */
++	{0x4A50 /* JP */, 926}, /* Japan */
++	{0x4A50 /* JP */, 927}, /* Japan */
++	{0x4A50 /* JP */, 928}, /* Japan */
++	{0x4A50 /* JP */, 929}, /* Japan */
++	{0x4A50 /* JP */, 930}, /* Japan */
++	{0x4A50 /* JP */, 931}, /* Japan */
++	{0x4A50 /* JP */, 932}, /* Japan */
++	{0x4A50 /* JP */, 933}, /* Japan */
++	{0x4A50 /* JP */, 934}, /* Japan */
++	{0x4A50 /* JP */, 935}, /* Japan */
++	{0x4A50 /* JP */, 936}, /* Japan */
++	{0x4A50 /* JP */, 937}, /* Japan */
++	{0x4A50 /* JP */, 938}, /* Japan */
++	{0x4A50 /* JP */, 939}, /* Japan */
++	{0x4A50 /* JP */, 940}, /* Japan */
++	{0x4A50 /* JP */, 941}, /* Japan */
++	{0x4B45 /* KE */, 404}, /* Kenya */
++	{0x4B50 /* KP */, 408}, /* North Korea */
++	{0x4B52 /* KR */, 410}, /* South Korea */
++	{0x4B52 /* KR */, 411}, /* South Korea */
++	{0x4B57 /* KW */, 414}, /* Kuwait */
++	{0x4B5A /* KZ */, 398}, /* Kazakhstan */
++	{0x4C42 /* LB */, 422}, /* Lebanon */
++	{0x4C49 /* LI */, 438}, /* Liechtenstein */
++	{0x4C54 /* LT */, 440}, /* Lithuania */
++	{0x4C55 /* LU */, 442}, /* Luxembourg */
++	{0x4C56 /* LV */, 428}, /* Latvia */
++	{0x4C59 /* LY */, 434}, /* Libya */
++	{0x4D41 /* MA */, 504}, /* Morocco */
++	{0x4D43 /* MC */, 492}, /* Principality of Monaco */
++	{0x4D4B /* MK */, 807}, /* the Former Yugoslav Republic of Macedonia */
++	{0x4D4F /* MO */, 446}, /* Macau */
++	{0x4D58 /* MX */, 484}, /* Mexico */
++	{0x4D59 /* MY */, 458}, /* Malaysia */
++	{0x4E49 /* NI */, 558}, /* Nicaragua */
++	{0x4E4C /* NL */, 528}, /* Netherlands */
++	{0x4E4F /* NO */, 578}, /* Norway */
++	{0x4E5A /* NZ */, 554}, /* New Zealand */
++	{0x4F4D /* OM */, 512}, /* Oman */
++	{0x5041 /* PA */, 591}, /* Panama */
++	{0x5045 /* PE */, 604}, /* Peru */
++	{0x5048 /* PH */, 608}, /* Republic of the Philippines */
++	{0x504B /* PK */, 586}, /* Islamic Republic of Pakistan */
++	{0x504C /* PL */, 616}, /* Poland */
++	{0x5052 /* PR */, 630}, /* Puerto Rico */
++	{0x5054 /* PT */, 620}, /* Portugal */
++	{0x5059 /* PY */, 600}, /* Paraguay */
++	{0x5141 /* QA */, 634}, /* Qatar */
++	{0x524F /* RO */, 642}, /* Romania */
++	{0x5255 /* RU */, 643}, /* Russia */
++	{0x5341 /* SA */, 682}, /* Saudi Arabia */
++	{0x5345 /* SE */, 752}, /* Sweden */
++	{0x5347 /* SG */, 702}, /* Singapore */
++	{0x5349 /* SI */, 705}, /* Slovenia */
++	{0x534B /* SK */, 703}, /* Slovak Republic */
++	{0x5356 /* SV */, 222}, /* El Salvador */
++	{0x5359 /* SY */, 760}, /* Syria */
++	{0x5448 /* TH */, 764}, /* Thailand */
++	{0x544E /* TN */, 788}, /* Tunisia */
++	{0x5452 /* TR */, 792}, /* Turkey */
++	{0x5454 /* TT */, 780}, /* Trinidad y Tobago */
++	{0x5457 /* TW */, 158}, /* Taiwan */
++	{0x5541 /* UA */, 804}, /* Ukraine */
++	{0x554B /* UK */, 826}, /* United Kingdom */
++	{0x5553 /* US */, 840}, /* United States */
++	{0x5553 /* US */, 842}, /* United States (Public Safety)*/
++	{0x5559 /* UY */, 858}, /* Uruguay */
++	{0x555A /* UZ */, 860}, /* Uzbekistan */
++	{0x5645 /* VE */, 862}, /* Venezuela */
++	{0x564E /* VN */, 704}, /* Viet Nam */
++	{0x5945 /* YE */, 887}, /* Yemen */
++	{0x5A41 /* ZA */, 710}, /* South Africa */
++	{0x5A57 /* ZW */, 716}, /* Zimbabwe */
++};
++
++int is_5g(const char *ifname)
++{
++	if (!strncmp(ifname, "ra"MIDFIX5G, 3))
++		return 1;
++	else if (!strncmp(ifname, "wds"MIDFIX5G, 4))
++		return 1;
++	else if (!strncmp(ifname, "apcli"MIDFIX5G, 6))
++		return 1;
++
++	return 0;
++}
++
++int is_rausb(const char *ifname)
++{
++	if (!strncmp(ifname, "rausb", 5))
++		return 1;
++
++	return 0;
++}
++
++static int ra_ioctl(const char *ifname, int cmd, struct iwreq *wrq)
++{
++	if (!strncmp(ifname, "mon.", 4))
++		strncpy(wrq->ifr_name, &ifname[4], IFNAMSIZ);
++	else
++		strncpy(wrq->ifr_name, ifname, IFNAMSIZ);
++
++	return iwinfo_ioctl(cmd, wrq);
++}
++
++int ra_oid_ioctl(const char *ifname, unsigned long oid, char *ptr, unsigned long ptr_len)
++{
++	struct iwreq wrq;
++	int cmd = RT_PRIV_IOCTL;
++	strcpy(wrq.ifr_name, ifname);
++	wrq.u.data.length = ptr_len;
++	wrq.u.data.pointer = ptr;
++	wrq.u.data.flags = oid;
++
++	return iwinfo_ioctl(RT_PRIV_IOCTL, &wrq);
++}
++
++int iwpriv_set(const char *name, const char *key, const char *val)
++{
++	int socket_id, ret = 0;
++	struct iwreq wrq;
++	char data[64];
++	snprintf(data, 64, "%s=%s", key, val);
++	socket_id = socket(AF_INET, SOCK_DGRAM, 0);
++
++	wrq.u.data.length = strlen(data);
++	wrq.u.data.pointer = data;
++	wrq.u.data.flags = 0;
++	ret = ra_ioctl(name, RTPRIV_IOCTL_SET, &wrq);
++	close(socket_id);
++	return ret;
++}
++
++int ra_probe(const char *ifname)
++{
++	unsigned char data[12];
++	int version;
++	if (ra_oid_ioctl(ifname, RT_OID_VERSION_INFO, data, sizeof(data)) >= 0)
++	{
++		data[1] = data[2];
++		data[2] = data[4];
++		data[3] = data[6];
++		data[4] = '\0';
++		version = atoi(data);
++		if (version >= 2500)
++			return 1;
++		else
++			return 0;
++	}
++	else
++		return -1;
++}
++
++void ra_close(void)
++{
++	iwinfo_close();
++}
++
++int ra_get_mode(const char *ifname, int *buf)
++{
++	if (is_rausb(ifname))
++	{
++		*buf = IWINFO_OPMODE_CLIENT;
++		return 0;
++	}
++
++	if (strncmp(ifname, "ra", 2) == 0)
++		*buf = IWINFO_OPMODE_MASTER;
++	else if (strncmp(ifname, "apcli", 5) == 0)
++		*buf = IWINFO_OPMODE_CLIENT;
++	else if (strncmp(ifname, "wds", 3) == 0)
++		*buf = IWINFO_OPMODE_WDS;
++	else
++		*buf = IWINFO_OPMODE_UNKNOWN;
++
++	return 0;
++}
++
++int ra_get_ssid(const char *ifname, char *buf)
++{
++	struct iwreq wrq;
++
++	wrq.u.essid.pointer = (caddr_t)buf;
++	wrq.u.essid.length = IW_ESSID_MAX_SIZE + 1;
++	wrq.u.essid.flags = 0;
++
++	if (ra_ioctl(ifname, SIOCGIWESSID, &wrq) >= 0)
++		return 0;
++
++	return -1;
++}
++
++int ra_get_bssid(const char *ifname, char *buf)
++{
++	struct iwreq wrq;
++
++	if (ra_ioctl(ifname, SIOCGIWAP, &wrq) >= 0)
++	{
++		sprintf(buf, "%02X:%02X:%02X:%02X:%02X:%02X",
++			(uint8_t)wrq.u.ap_addr.sa_data[0], (uint8_t)wrq.u.ap_addr.sa_data[1],
++			(uint8_t)wrq.u.ap_addr.sa_data[2], (uint8_t)wrq.u.ap_addr.sa_data[3],
++			(uint8_t)wrq.u.ap_addr.sa_data[4], (uint8_t)wrq.u.ap_addr.sa_data[5]);
++
++		return 0;
++	}
++
++	return -1;
++}
++
++static int32_t ra_freq2mhz(const struct iw_freq *in)
++{
++	int i;
++	int32_t res = in->m;
++	if (in->e == 6) {
++		return res;
++	} else if (in->e > 6) {
++		for (i=in->e; i>6; --i) {
++			res *= 10;
++		}
++	} else {
++		for (i=in->e; i<6; ++i) {
++			res /= 10;
++		}
++	}
++	return res;
++}
++
++int ra_get_channel(const char *ifname, int *buf)
++{
++	struct iwreq wrq;
++
++	if (ra_ioctl(ifname, SIOCGIWFREQ, &wrq) >= 0)
++	{
++		*buf = wrq.u.freq.i;
++		return 0;
++	}
++
++	return -1;
++}
++
++int ra_get_frequency(const char *ifname, int *buf)
++{
++	struct iwreq wrq;
++
++	if (is_rausb(ifname))
++		return wext_get_frequency(ifname, buf);
++
++	if (ra_ioctl(ifname, SIOCGIWFREQ, &wrq) >= 0)
++	{
++		*buf = ra_freq2mhz(&wrq.u.freq);
++		return 0;
++	}
++	return -1;
++}
++
++int ra_get_txpower(const char *ifname, int *buf)
++{
++	*buf = 20;
++	return 0;
++}
++
++int ra_get_bitrate(const char *ifname, int *buf)
++{
++	struct iwreq wrq;
++
++	if (ra_ioctl(ifname, SIOCGIWRATE, &wrq) >= 0)
++	{
++		*buf = (wrq.u.bitrate.value / 1000);
++		return 0;
++	}
++
++	return -1;
++}
++
++int ra_get_signal(const char *ifname, int *buf)
++{
++	int ra_snr_sum, num;
++	char tmp_buf[8192];
++	struct iwinfo_assoclist_entry tmp;
++	int ret_len, i;
++
++	if (ra_get_assoclist(ifname, tmp_buf, &ret_len) == 0)
++	{
++		num = ret_len / sizeof(struct iwinfo_assoclist_entry);
++		ra_snr_sum = 0;
++		for (i = 0; i < num; i++)
++		{
++			memset(&tmp, 0, sizeof(struct iwinfo_assoclist_entry));
++			memcpy(&tmp, tmp_buf + i * sizeof(struct iwinfo_assoclist_entry), sizeof(struct iwinfo_assoclist_entry));
++
++			ra_snr_sum -= tmp.signal;
++		}
++		if (num > 0)
++			*buf = -(ra_snr_sum / num);
++		else
++			*buf = -95;
++
++		return 0;
++	}
++	else
++		return -1;
++}
++
++int ra_get_noise(const char *ifname, int *buf)
++{
++	*buf = -95;
++	return 0;
++}
++
++int ra_get_quality(const char *ifname, int *buf)
++{
++	int tmp;
++	if (is_rausb(ifname))
++		return wext_get_quality(ifname, buf);
++
++	if (ra_get_signal(ifname, &tmp) == 0)
++		*buf = 100 - (tmp / -95 * 100);
++	else
++		*buf = 100;
++
++	return 0;
++}
++
++int ra_get_quality_max(const char *ifname, int *buf)
++{
++	if (is_rausb(ifname))
++		return wext_get_quality_max(ifname, buf);
++
++	*buf = 100;
++	return 0;
++}
++
++static char *ra_array_get(char *p, int idx) {
++	int i;
++	char *tail;
++	for (i=0; i<idx; ++i) {
++		p = strchr(p, ';');
++		if (p == NULL) {
++			return NULL;
++		}
++		p += 1;
++	}
++	tail = strchr(p, ';');
++	if (!tail) {
++		tail = strchr(p, '\n');
++	}
++	if (!tail) {
++		*tail = '\0';
++	}
++	return p;
++}
++
++int ra_get_encryption(const char *ifname, char *buf)
++{
++	FILE *fp;
++	const char *filename;
++	long filesize;
++	int ret = -1;
++	char buffer[256] = {0};
++	char *p = NULL;
++	int idx;
++	int aes = 0;
++
++	struct iwinfo_crypto_entry *enc = (struct iwinfo_crypto_entry *)buf;
++
++	char data[10];
++	if (ra_oid_ioctl(ifname, RT_OID_VERSION_INFO, data, sizeof(data)) < 0)
++		return -1;
++
++	if (is_5g(ifname)) {
++		filename = "/tmp/profiles/mt_dbdc_5g.dat";
++	} else {
++		filename = "/tmp/profiles/mt_dbdc_2g.dat";
++	}
++	fp = fopen(filename, "r");
++	if (fp == NULL)
++	{
++		fprintf(stderr, "open ifname:%s failed.\n", ifname);
++		return -1;
++	}
++	idx = ifname[strlen(ifname)-1] - '0';
++	while (fgets(buffer, sizeof(buffer), fp) != NULL) {
++		if (!strncmp(buffer, "AuthMode=", 9)) {
++			p = buffer + 9;
++			p = ra_array_get(p, idx);
++			if (!p)
++				goto end;
++			if (strstr(p, "WPA"))
++			{
++				enc->enabled = 1;
++				if (strstr(p, "WPA1PSKWPA2PSK"))
++					enc->wpa_version = 3;
++				else if (strstr(p, "WPA2PSK"))
++					enc->wpa_version = 2;
++				else if (strstr(p, "WPAPSK"))
++					enc->wpa_version = 1;
++				else
++					enc->wpa_version = 1;
++
++				enc->auth_suites |= IWINFO_KMGMT_PSK;
++			}
++			else if (strstr(p, "WEP"))
++			{
++				enc->enabled = 1;
++				enc->auth_algs |= IWINFO_AUTH_OPEN;
++				enc->pair_ciphers |= IWINFO_CIPHER_WEP104;
++				enc->auth_suites |= IWINFO_KMGMT_NONE;
++				enc->group_ciphers = enc->pair_ciphers;
++			}
++		} else if (!strncmp(buffer, "EncrypType=", 11)) {
++			if (enc->pair_ciphers & IWINFO_CIPHER_WEP104)
++				continue;
++			p = buffer + 11;
++			p = ra_array_get(p, idx);
++			if (!p)
++				goto end;
++			if (strstr(p, "AES"))
++				aes = 1;
++		}
++	}
++
++	if (enc->enabled && enc->auth_suites & IWINFO_KMGMT_PSK) {
++		if (aes)
++			enc->pair_ciphers |= IWINFO_CIPHER_CCMP;
++		else
++			enc->pair_ciphers |= IWINFO_CIPHER_TKIP;
++
++		enc->group_ciphers = enc->pair_ciphers;
++	}
++
++	ret = 0;
++end:
++	fclose(fp);
++	return ret;
++}
++
++int ra_get_phyname(const char *ifname, char *buf) {
++	if (is_5g(ifname)) {
++		strcpy(buf, "ra"MIDFIX5G);
++	} else {
++		strcpy(buf, "ra");
++	}
++	return 0;
++}
++
++int getRate(MACHTTRANSMIT_SETTING HTSetting)
++{
++	int MCSMappingRateTable[] =
++	    {
++		2, 4, 11, 22,								    /* CCK*/
++		12, 18, 24, 36, 48, 72, 96, 108,					    /* OFDM*/
++		13, 26, 39, 52, 78, 104, 117, 130, 26, 52, 78, 104, 156, 208, 234, 260,	    /* 20MHz, 800ns GI, MCS: 0 ~ 15*/
++		39, 78, 117, 156, 234, 312, 351, 390,					    /* 20MHz, 800ns GI, MCS: 16 ~ 23*/
++		27, 54, 81, 108, 162, 216, 243, 270, 54, 108, 162, 216, 324, 432, 486, 540, /* 40MHz, 800ns GI, MCS: 0 ~ 15*/
++		81, 162, 243, 324, 486, 648, 729, 810,					    /* 40MHz, 800ns GI, MCS: 16 ~ 23*/
++		14, 29, 43, 57, 87, 115, 130, 144, 29, 59, 87, 115, 173, 230, 260, 288,	    /* 20MHz, 400ns GI, MCS: 0 ~ 15*/
++		43, 87, 130, 173, 260, 317, 390, 433,					    /* 20MHz, 400ns GI, MCS: 16 ~ 23*/
++		30, 60, 90, 120, 180, 240, 270, 300, 60, 120, 180, 240, 360, 480, 540, 600, /* 40MHz, 400ns GI, MCS: 0 ~ 15*/
++		90, 180, 270, 360, 540, 720, 810, 900,
++		13, 26, 39, 52, 78, 104, 117, 130, 156,		 /* 11ac: 20Mhz, 800ns GI, MCS: 0~8 */
++		27, 54, 81, 108, 162, 216, 243, 270, 324, 360,	 /*11ac: 40Mhz, 800ns GI, MCS: 0~9 */
++		59, 117, 176, 234, 351, 468, 527, 585, 702, 780, /*11ac: 80Mhz, 800ns GI, MCS: 0~9 */
++		14, 29, 43, 57, 87, 115, 130, 144, 173,		 /* 11ac: 20Mhz, 400ns GI, MCS: 0~8 */
++		30, 60, 90, 120, 180, 240, 270, 300, 360, 400,	 /*11ac: 40Mhz, 400ns GI, MCS: 0~9 */
++		65, 130, 195, 260, 390, 520, 585, 650, 780, 867	 /*11ac: 80Mhz, 400ns GI, MCS: 0~9 */
++	    };
++
++	int rate_count = sizeof(MCSMappingRateTable) / sizeof(int);
++	int rate_index = 0;
++	int value = 0;
++
++	if (HTSetting.field.MODE >= 4)
++	{
++		if (HTSetting.field.BW == 0)
++		{
++			rate_index = 108 +
++				     ((unsigned char)HTSetting.field.ShortGI * 29) +
++				     ((unsigned char)HTSetting.field.MCS);
++		}
++		else if (HTSetting.field.BW == 1)
++		{
++			rate_index = 117 +
++				     ((unsigned char)HTSetting.field.ShortGI * 29) +
++				     ((unsigned char)HTSetting.field.MCS);
++		}
++		else if (HTSetting.field.BW == 2)
++		{
++			rate_index = 127 +
++				     ((unsigned char)HTSetting.field.ShortGI * 29) +
++				     ((unsigned char)HTSetting.field.MCS);
++		}
++	}
++	else if (HTSetting.field.MODE >= 2)
++	{
++		/*    	rate_index = 12 + ((UCHAR)ht_setting.field.BW *16) + ((UCHAR)ht_setting.field.ShortGI *32) + ((UCHAR)ht_setting.field.MCS);*/
++		rate_index = 12 + ((unsigned char)HTSetting.field.BW * 24) + ((unsigned char)HTSetting.field.ShortGI * 48) + ((unsigned char)HTSetting.field.MCS);
++	}
++	else if (HTSetting.field.MODE == 1)
++		rate_index = (unsigned char)(HTSetting.field.MCS) + 4;
++	else if (HTSetting.field.MODE == 0)
++		rate_index = (unsigned char)(HTSetting.field.MCS);
++
++	if (rate_index < 0)
++		rate_index = 0;
++
++	if (rate_index >= rate_count)
++		rate_index = rate_count - 1;
++
++	return (MCSMappingRateTable[rate_index] * 5 * 100);
++}
++
++int ra_get_assoclist(const char *ifname, char *buf, int *len)
++{
++	int ret, i;
++	int bl = 0, tl, noise;
++	struct iwreq wrq;
++	struct iwinfo_assoclist_entry entry;
++
++	if (!strncmp(ifname, "apcli", 5))
++		return -1;
++
++	if (is_rausb(ifname))
++		return -1;
++
++	char table[8192];
++
++	wrq.u.data.pointer = (caddr_t)&table;
++	wrq.u.data.flags = 0;
++
++	ret = ra_ioctl(ifname, RTPRIV_IOCTL_GET_MAC_TABLE_STRUCT, &wrq);
++	if (ret < 0)
++	{
++		printf("assoclist ioctl fails\n");
++		return -1;
++	}
++
++	RT_802_11_MAC_TABLE *a = &table;
++
++	char iface[4];
++
++	*len = a->Num * sizeof(struct iwinfo_assoclist_entry);
++
++	for (i = 0; i < a->Num; i++)
++	{
++		RT_802_11_MAC_ENTRY *pe = &(a->Entry[i]);
++		memset(&entry, 0, sizeof(entry));
++		memset(&iface, 0, sizeof(iface));
++		if (is_5g(ifname))
++			sprintf(iface, "ra"MIDFIX5G"%d", pe->ApIdx);
++		else
++			sprintf(iface, "ra%d", pe->ApIdx);
++
++		if (strncmp(iface, ifname, sizeof(iface)) == 0)
++		{
++			entry.signal = ((int)(pe->AvgRssi0) + (int)(pe->AvgRssi1)) / 2;
++
++			entry.noise = -95;
++			entry.inactive = pe->ConnectedTime * 1000;
++
++			memcpy(&entry.mac, &pe->Addr, sizeof(entry.mac));
++
++			entry.tx_packets = 0;
++			entry.rx_packets = 0;
++
++			entry.tx_rate.rate = getRate(pe->TxRate);
++			entry.tx_rate.mcs = pe->TxRate.field.MCS;
++			entry.tx_rate.is_40mhz = pe->TxRate.field.BW;
++			entry.tx_rate.is_short_gi = pe->TxRate.field.ShortGI;
++
++			entry.rx_rate = entry.tx_rate;
++
++			memcpy(&buf[bl], &entry, sizeof(struct iwinfo_assoclist_entry));
++
++			bl += sizeof(struct iwinfo_assoclist_entry);
++		}
++
++		*len = bl;
++	}
++	return 0;
++}
++
++int ra_get_txpwrlist(const char *ifname, char *buf, int *len)
++{
++	struct iwinfo_txpwrlist_entry entry;
++	uint8_t dbm[11] = {0, 6, 8, 10, 12, 14, 16, 18, 20};
++	uint8_t mw[11] = {1, 3, 6, 10, 15, 25, 39, 63, 100};
++	int i;
++
++	for (i = 0; i < 11; i++)
++	{
++		entry.dbm = dbm[i];
++		entry.mw = mw[i];
++		memcpy(&buf[i * sizeof(entry)], &entry, sizeof(entry));
++	}
++
++	*len = 11 * sizeof(entry);
++	return 0;
++}
++
++static void bssid2mac(char *macStr, unsigned char *mac)
++{
++	unsigned int iMac[6];
++	int i;
++	sscanf(macStr, "%x:%x:%x:%x:%x:%x", &iMac[0], &iMac[1], &iMac[2], &iMac[3], &iMac[4], &iMac[5]);
++	for (i = 0; i < 6; i++)
++		mac[i] = (unsigned char)iMac[i];
++}
++
++static void parse_security(char *sec, struct iwinfo_crypto_entry *enc)
++{
++	memset(enc, 0, sizeof(struct iwinfo_crypto_entry));
++	enc->enabled = 0;
++	if (strstr(sec, "WPA"))
++	{
++		enc->enabled = 1;
++		if (strstr(sec, "WPA1PSKWPA2PSK"))
++			enc->wpa_version = 3;
++		else if (strstr(sec, "WPA2PSK"))
++			enc->wpa_version = 2;
++		else if (strstr(sec, "WPAPSK"))
++			enc->wpa_version = 1;
++		else if (strstr(sec, "WPA"))
++			enc->wpa_version = 1;
++
++		enc->auth_suites |= IWINFO_KMGMT_PSK;
++
++		if (strstr(sec, "AES"))
++			enc->pair_ciphers |= IWINFO_CIPHER_CCMP;
++		else
++			enc->pair_ciphers |= IWINFO_CIPHER_TKIP;
++
++		enc->group_ciphers = enc->pair_ciphers;
++	}
++	else if (strstr(sec, "WEP"))
++	{
++		enc->enabled = 1;
++		enc->auth_algs |= IWINFO_AUTH_OPEN;
++		enc->pair_ciphers |= IWINFO_CIPHER_WEP104;
++		enc->auth_suites |= IWINFO_KMGMT_NONE;
++		enc->group_ciphers = enc->pair_ciphers;
++	}
++}
++
++int rtrim(char *s)
++{
++	int i;
++
++	i = strlen(s) - 1;
++	while ((s[i] == ' ' || s[i] == '\t') && i >= 0)
++	{
++		i--;
++	};
++	s[i + 1] = '\0';
++	return i + 1;
++}
++
++static void fill_find_entry(char *sp, struct iwinfo_scanlist_entry *e)
++{
++	char site_channel[4];
++	char site_ssid[33];
++	char site_bssid[20];
++	char site_security[23];
++	char site_signal[9];
++	char site_wirelessmode[7];
++	char ssid_str[128];
++	int len;
++
++	memcpy(site_channel, sp, 4);
++	memcpy(site_ssid, sp + 4, 33);
++	memcpy(site_bssid, sp + 37, 20);
++	memcpy(site_security, sp + 57, 23);
++	memcpy(site_signal, sp + 80, 9);
++
++	rtrim(site_bssid);
++	rtrim(site_channel);
++	rtrim(site_security);
++	rtrim(site_signal);
++
++	e->channel = atoi(site_channel);
++	bssid2mac((unsigned char *)site_bssid, (unsigned char *)e->mac);
++	e->mode = IWINFO_OPMODE_MASTER;
++	//e->crypto.enable = 0;
++	parse_security((char *)site_security, &e->crypto);
++
++	int quality = atoi(site_signal);
++	int8_t rssi;
++	rssi = (quality * 95 / 100) - 95;
++
++	if (quality < 5)
++	{
++		rssi = -95;
++	}
++
++	e->signal = rssi;
++	e->quality = quality;
++	e->quality_max = 100;
++
++	len = rtrim(site_ssid);
++	if (!strlen(site_ssid))
++	{
++		strcpy(site_ssid, "???");
++		len = 3;
++	}
++	memcpy(e->ssid, site_ssid, len);
++}
++
++int ra_get_scanlist(const char *ifname, char *buf, int *len)
++{
++	struct iwreq wrq;
++	char data[8192];
++	memset(data, 0, 32);
++	char *sp, *op, *empty;
++
++	int len_a, line_len;
++
++	if (is_rausb(ifname))
++		return wext_get_scanlist(ifname, buf, len);
++
++	iwpriv_set(ifname, "SiteSurvey", "1");
++	sleep(3);
++
++	memset(data, 0, sizeof(data));
++	wrq.u.data.length = sizeof(data);
++	wrq.u.data.pointer = data;
++	wrq.u.data.flags = 0;
++
++	if (ra_ioctl(ifname, RTPRIV_IOCTL_GSITESURVEY, &wrq) >= 0)
++	{
++		struct iwinfo_scanlist_entry e;
++		line_len = 4 + 33 + 20 + 23 + 9 + 7 + 7 + 3;
++		if (wrq.u.data.length < 1)
++			return -1;
++		op = sp = wrq.u.data.pointer + line_len + 2; // skip \n+\n
++		len_a = strlen(op);
++		int i = 0;
++		while (*sp && ((len_a - (sp - op)) >= 0))
++		{
++			memset(&e, 0, sizeof(struct iwinfo_scanlist_entry));
++
++			fill_find_entry(sp, &e);
++
++			memcpy(&buf[i * sizeof(struct iwinfo_scanlist_entry)], &e, sizeof(struct iwinfo_scanlist_entry));
++
++			i++;
++			sp += line_len + 1; // skip \n
++		}
++		*len = i * sizeof(struct iwinfo_scanlist_entry);
++		return 0;
++	}
++	return -1;
++}
++
++#define RA_MAX_CH_2G 13
++static const uint8_t CH5G[]={
++	/* 802.11 UNI / HyperLan 2 */
++	36, 40, 44, 48, 52, 56, 60, 64, //8
++
++	/* 802.11 HyperLan 2 */
++	100, 104, 108, 112, 116, 120, 124, 128, 132, 136, //10
++
++	/* 802.11 UNII */
++	140, 144, 149, 153, 157, 161, 165
++};
++
++int ra_get_freqlist(const char *ifname, char *buf, int *len)
++{
++
++	struct iwinfo_freqlist_entry entry;
++	int i, bl;
++	bl = 0;
++
++	if (is_rausb(ifname))
++		return wext_get_freqlist(ifname, buf, len);
++
++	if (is_5g(ifname)) {
++		for (i=0; i<ARRAY_SIZE(CH5G); ++i) {
++			entry.mhz = 5000 + 5 * CH5G[i];
++			entry.channel =  CH5G[i];
++			entry.restricted = 0;
++
++			memcpy(&buf[bl], &entry, sizeof(struct iwinfo_freqlist_entry));
++			bl += sizeof(struct iwinfo_freqlist_entry);
++		}
++	} else {
++		for (i = 0; i < RA_MAX_CH_2G; i++)
++		{
++			entry.mhz = 2412 + 5 * i;
++			entry.channel = i + 1;
++			entry.restricted = 0;
++
++			memcpy(&buf[bl], &entry, sizeof(struct iwinfo_freqlist_entry));
++			bl += sizeof(struct iwinfo_freqlist_entry);
++		}
++	}
++
++	*len = bl;
++	return 0;
++}
++
++int ra_get_country(const char *ifname, char *buf)
++{
++	char data[10];
++	if (ra_oid_ioctl(ifname, RT_OID_VERSION_INFO, data, sizeof(data)) < 0)
++		return -1;
++	strncpy(buf, "US", 2);
++	return 0;
++}
++
++int ra_get_countrylist(const char *ifname, char *buf, int *len)
++{
++
++	int i, count;
++	struct ISO3166_to_CCode *e, *p = NULL;
++	struct iwinfo_country_entry *c = (struct iwinfo_country_entry *)buf;
++	char data[10];
++	if (ra_oid_ioctl(ifname, RT_OID_VERSION_INFO, data, sizeof(data)) < 0)
++		return -1;
++	count = 0;
++
++	for (int i = 0; i < (sizeof(CountryCodes) / sizeof(CountryCodes[0])); i++)
++	{
++		e = &CountryCodes[i];
++
++		if (!p || (e->iso3166 != p->iso3166))
++		{
++			c->iso3166 = e->iso3166;
++			snprintf(c->ccode, sizeof(c->ccode), "%i", e->ccode);
++
++			c++;
++			count++;
++		}
++
++		p = e;
++	}
++
++	*len = (count * sizeof(struct iwinfo_country_entry));
++	return 0;
++}
++
++int ra_get_hwmodelist(const char *ifname, int *buf)
++{
++	char data[10];
++	if (is_rausb(ifname))
++		return wext_get_hwmodelist(ifname, buf);
++
++	if (ra_oid_ioctl(ifname, RT_OID_VERSION_INFO, data, sizeof(data)) < 0)
++		return -1;
++	if (is_5g(ifname))
++	{
++		*buf |= IWINFO_80211_A;
++		*buf |= IWINFO_80211_N;
++	}
++	else
++	{
++		*buf |= IWINFO_80211_B;
++		*buf |= IWINFO_80211_G;
++		*buf |= IWINFO_80211_N;
++	}
++
++	return 0;
++}
++
++int ra_get_htmodelist(const char *ifname, int *buf) {
++	*buf = IWINFO_HTMODE_HT20 | IWINFO_HTMODE_HT40 | IWINFO_HTMODE_VHT20 | IWINFO_HTMODE_VHT40 | IWINFO_HTMODE_VHT80;
++
++	return 0;
++}
++
++int ra_get_mbssid_support(const char *ifname, int *buf)
++{
++	char data[10];
++	if (is_rausb(ifname))
++	{
++		*buf = 0;
++		return 0;
++	}
++
++	if (ra_oid_ioctl(ifname, RT_OID_VERSION_INFO, data, sizeof(data)) < 0)
++		return -1;
++	*buf = 1;
++	return 0;
++}
++
++int ra_get_hardware_id(const char *ifname, char *buf)
++{
++	struct iwinfo_hardware_id *id = (struct iwinfo_hardware_id *)buf;
++	memset(id, 0, sizeof(struct iwinfo_hardware_id));
++	char data[10];
++	if (ra_oid_ioctl(ifname, RT_OID_VERSION_INFO, data, sizeof(data)) < 0 && !is_rausb(ifname))
++		return -1;
++	id->vendor_id = 0x1814;
++	id->device_id = 0x7615;
++	id->subsystem_device_id = 0x0;
++	id->subsystem_vendor_id = 0x1814;
++
++	return (id->vendor_id > 0 && id->device_id > 0) ? 0 : -1;
++}
++
++int ra_get_hardware_name(const char *ifname, char *buf)
++{
++	char data[10];
++
++	if (ra_oid_ioctl(ifname, RT_OID_VERSION_INFO, data, sizeof(data)) < 0)
++		return -1;
++	sprintf(buf, "MT7615");
++
++	return 0;
++}
++
++int ra_get_txpower_offset(const char *ifname, int *buf)
++{
++	/* Stub */
++	*buf = 0;
++	return -1;
++}
++
++int ra_get_frequency_offset(const char *ifname, int *buf)
++{
++	/* Stub */
++	*buf = 0;
++	return -1;
++}
+--- /dev/null
++++ b/iwinfo_ra.h
+@@ -0,0 +1,74 @@
++#ifndef __IWINFO_RA_H_
++#define __IWINFO_RA_H_
++
++#include <fcntl.h>
++
++#include "iwinfo.h"
++#include "iwinfo/utils.h"
++
++
++#include "api/ralink.h"
++
++int ra_probe(const char *ifname);
++int ra_get_mode(const char *ifname, int *buf);
++int ra_get_ssid(const char *ifname, char *buf);
++int ra_get_bssid(const char *ifname, char *buf);
++int ra_get_country(const char *ifname, char *buf);
++int ra_get_channel(const char *ifname, int *buf);
++int ra_get_frequency(const char *ifname, int *buf);
++int ra_get_frequency_offset(const char *ifname, int *buf);
++int ra_get_txpower(const char *ifname, int *buf);
++int ra_get_txpower_offset(const char *ifname, int *buf);
++int ra_get_bitrate(const char *ifname, int *buf);
++int ra_get_signal(const char *ifname, int *buf);
++int ra_get_noise(const char *ifname, int *buf);
++int ra_get_quality(const char *ifname, int *buf);
++int ra_get_quality_max(const char *ifname, int *buf);
++int ra_get_enctype(const char *ifname, char *buf);
++int ra_get_encryption(const char *ifname, char *buf);
++int ra_get_phyname(const char *ifname, char *buf);
++int ra_get_assoclist(const char *ifname, char *buf, int *len);
++int ra_get_txpwrlist(const char *ifname, char *buf, int *len);
++int ra_get_scanlist(const char *ifname, char *buf, int *len);
++int ra_get_freqlist(const char *ifname, char *buf, int *len);
++int ra_get_countrylist(const char *ifname, char *buf, int *len);
++int ra_get_hwmodelist(const char *ifname, int *buf);
++int ra_get_htmodelist(const char *ifname, int *buf);
++int ra_get_mbssid_support(const char *ifname, int *buf);
++int ra_get_hardware_id(const char *ifname, char *buf);
++int ra_get_hardware_name(const char *ifname, char *buf);
++void ra_close(void);
++
++const struct iwinfo_ops ra_ops = {
++	.name             = "ra",
++	.probe            = ra_probe,
++	.channel          = ra_get_channel,
++	.frequency        = ra_get_frequency,
++	.frequency_offset = ra_get_frequency_offset,
++	.txpower          = ra_get_txpower,
++	.txpower_offset   = ra_get_txpower_offset,
++	.bitrate          = ra_get_bitrate,
++	.signal           = ra_get_signal,
++	.noise            = ra_get_noise,
++	.quality          = ra_get_quality,
++	.quality_max      = ra_get_quality_max,
++	.mbssid_support   = ra_get_mbssid_support,
++	.hwmodelist       = ra_get_hwmodelist,
++	.htmodelist       = ra_get_htmodelist,
++	.mode             = ra_get_mode,
++	.ssid             = ra_get_ssid,
++	.bssid            = ra_get_bssid,
++	.country          = ra_get_country,
++	.hardware_id      = ra_get_hardware_id,
++	.hardware_name    = ra_get_hardware_name,
++	.encryption       = ra_get_encryption,
++	.phyname          = ra_get_phyname,
++	.assoclist        = ra_get_assoclist,
++	.txpwrlist        = ra_get_txpwrlist,
++	.scanlist         = ra_get_scanlist,
++	.freqlist         = ra_get_freqlist,
++	.countrylist      = ra_get_countrylist,
++	.close            = ra_close
++};
++
++#endif
+--- a/iwinfo_wext.c
++++ b/iwinfo_wext.c
+@@ -185,7 +185,7 @@ static int wext_get_channel(const char *
+ 	return -1;
+ }
+ 
+-static int wext_get_frequency(const char *ifname, int *buf)
++int wext_get_frequency(const char *ifname, int *buf)
+ {
+ 	struct iwreq wrq;
+ 	struct iw_range range;
+@@ -282,7 +282,7 @@ static int wext_get_noise(const char *if
+ 	return -1;
+ }
+ 
+-static int wext_get_quality(const char *ifname, int *buf)
++int wext_get_quality(const char *ifname, int *buf)
+ {
+ 	struct iwreq wrq;
+ 	struct iw_statistics stats;
+@@ -300,7 +300,7 @@ static int wext_get_quality(const char *
+ 	return -1;
+ }
+ 
+-static int wext_get_quality_max(const char *ifname, int *buf)
++int wext_get_quality_max(const char *ifname, int *buf)
+ {
+ 	struct iwreq wrq;
+ 	struct iw_range range;
+@@ -365,7 +365,7 @@ static int wext_get_txpwrlist(const char
+ 	return -1;
+ }
+ 
+-static int wext_get_freqlist(const char *ifname, char *buf, int *len)
++int wext_get_freqlist(const char *ifname, char *buf, int *len)
+ {
+ 	struct iwreq wrq;
+ 	struct iw_range range;
+@@ -409,7 +409,7 @@ static int wext_get_countrylist(const ch
+ 	return -1;
+ }
+ 
+-static int wext_get_hwmodelist(const char *ifname, int *buf)
++int wext_get_hwmodelist(const char *ifname, int *buf)
+ {
+ 	char chans[IWINFO_BUFSIZE] = { 0 };
+ 	struct iwinfo_freqlist_entry *e = NULL;
+--- a/Makefile
++++ b/Makefile
+@@ -32,6 +32,15 @@ ifneq ($(filter nl80211,$(IWINFO_BACKEND
+ 	IWINFO_LIB_OBJ     += iwinfo_nl80211.o
+ endif
+ 
++ifneq ($(filter ra,$(IWINFO_BACKENDS)),)
++   IWINFO_CFLAGS  += -DUSE_RA
++   IWINFO_LIB_OBJ += iwinfo_ra.o
++endif
++
++ifneq ($(filter rt2860v2,$(IWINFO_BACKENDS)),)
++   IWINFO_CFLAGS  += -DUSE_RA -DUSE_RT2860
++   IWINFO_LIB_OBJ += iwinfo_ra.o
++endif
+ 
+ %.o: %.c
+ 	$(CC) $(IWINFO_CFLAGS) $(FPIC) -c -o $@ $<
+--- a/hardware.txt
++++ b/hardware.txt
+@@ -173,6 +173,34 @@
+ 0x1814 0x3662 0x1814 0x000d    0      0  "Ralink"   "Rt3662"
+ 0x1814 0x3883 0x1814 0x000d    0      0  "Ralink"   "Rt3883"
+ 0x1814 0x5350 0x1814 0x000f    0      0  "Ralink"   "Rt5350"
++/* MT7620 */
++0x1814 0x7620 0x1814 0x0000    0      0  "Mediatek" "MT7620"
++0x1814 0x7620 0x1814 0xffff    0      0  "Mediatek" "MT7620"
++0x1814 0x7620 0x1814 0x7620    0      0  "Mediatek" "MT7620"
++/* MT7610 */
++0x1814 0x7610 0x1814 0x0000    0      0  "Mediatek" "MT7610"
++0x1814 0x7610 0x1814 0xffff    0      0  "Mediatek" "MT7610"
++0x1814 0x7610 0x1814 0x7610    0      0  "Mediatek" "MT7610"
++/* MT7602/MT7612/MT7662 */
++0x1814 0x7662 0x1814 0x0000    0      0  "Mediatek" "MT7612"
++0x1814 0x7662 0x1814 0xffff    0      0  "Mediatek" "MT7612"
++0x1814 0x7662 0x1814 0x7602    0      0  "Mediatek" "MT7602"
++0x1814 0x7662 0x1814 0x7612    0      0  "Mediatek" "MT7612"
++0x1814 0x7662 0x1814 0x7662    0      0  "Mediatek" "MT7662"
++/* MT7603 */
++0x1814 0x7603 0x1814 0x0000    0      0  "Mediatek" "MT7603"
++0x1814 0x7603 0x1814 0xffff    0      0  "Mediatek" "MT7603"
++0x1814 0x7603 0x1814 0x7603    0      0  "Mediatek" "MT7603"
++/* MT7628/MT7688 */
++0x1814 0x7628 0x1814 0x0000    0      0  "Mediatek" "MT7628"
++0x1814 0x7628 0x1814 0xffff    0      0  "Mediatek" "MT7628"
++0x1814 0x7628 0x1814 0x7628    0      0  "Mediatek" "MT7628"
++0x1814 0x7628 0x1814 0x7688    0      0  "Mediatek" "MT7688"
++/* MT7615 */
++0x1814 0x7615 0x1814 0x0000    0      0  "Mediatek" "MT7615"
++0x1814 0x7615 0x1814 0xffff    0      0  "Mediatek" "MT7615"
++0x1814 0x7615 0x1814 0x7615    0      0  "Mediatek" "MT7615"
++
+ 0x11ab 0x2a55 0x11ab 0x0000    0      0  "Marvell"  "88W8864"
+ 0x02df 0x9135 0x0000 0x0000    0      0  "Marvell"  "88W8887"
+ 0x11ab 0x2b40 0x11ab 0x0000    0      0  "Marvell"  "88W8964"
diff --git a/target/linux/ramips/image/mt7621.mk b/target/linux/ramips/image/mt7621.mk
index 9ead1c0b8cc..9f0d4d62b27 100644
--- a/target/linux/ramips/image/mt7621.mk
+++ b/target/linux/ramips/image/mt7621.mk
@@ -817,7 +817,7 @@ define Device/phicomm_k2p
   DEVICE_VENDOR := Phicomm
   DEVICE_MODEL := K2P
   SUPPORTED_DEVICES += k2p
-  DEVICE_PACKAGES := kmod-mt7615d luci-app-mtwifi
+  DEVICE_PACKAGES := kmod-mt7615d
 endef
 TARGET_DEVICES += phicomm_k2p
 

From cd3cd1a9f7a1dcf56e0b17c352bb48272443bdfc Mon Sep 17 00:00:00 2001
From: jjm2473 <1129525450@qq.com>
Date: Fri, 27 Nov 2020 12:33:47 +0800
Subject: [PATCH 02/20] iwinfo: support ra frequency offset

---
 package/network/utils/iwinfo/patches/001-ralink.patch | 6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

diff --git a/package/network/utils/iwinfo/patches/001-ralink.patch b/package/network/utils/iwinfo/patches/001-ralink.patch
index 995066f67c8..7435998cff9 100644
--- a/package/network/utils/iwinfo/patches/001-ralink.patch
+++ b/package/network/utils/iwinfo/patches/001-ralink.patch
@@ -339,7 +339,7 @@
  	luaL_register(L, NULL, R_common);
 --- /dev/null
 +++ b/iwinfo_ra.c
-@@ -0,0 +1,1025 @@
+@@ -0,0 +1,1023 @@
 +#include "iwinfo.h"
 +#include "iwinfo_ra.h"
 +#include "iwinfo_wext.h"
@@ -1361,9 +1361,7 @@
 +
 +int ra_get_frequency_offset(const char *ifname, int *buf)
 +{
-+	/* Stub */
-+	*buf = 0;
-+	return -1;
++	return ra_get_frequency(ifname, buf);
 +}
 --- /dev/null
 +++ b/iwinfo_ra.h

From 14b24b77c8cccdbe20155f619c09d5ead33f469d Mon Sep 17 00:00:00 2001
From: jjm2473 <1129525450@qq.com>
Date: Sat, 28 Nov 2020 12:29:05 +0800
Subject: [PATCH 03/20] iwinfo: ra support assolist, support AC bandwidth, read
 device id from mtd

---
 .../utils/iwinfo/patches/001-ralink.patch     | 135 +++++++-----------
 1 file changed, 55 insertions(+), 80 deletions(-)

diff --git a/package/network/utils/iwinfo/patches/001-ralink.patch b/package/network/utils/iwinfo/patches/001-ralink.patch
index 7435998cff9..248f837e52f 100644
--- a/package/network/utils/iwinfo/patches/001-ralink.patch
+++ b/package/network/utils/iwinfo/patches/001-ralink.patch
@@ -1,6 +1,6 @@
 --- /dev/null
 +++ b/api/ralink.h
-@@ -0,0 +1,205 @@
+@@ -0,0 +1,207 @@
 +#ifndef _RALINK_H
 +#define _RALINK_H
 +
@@ -173,12 +173,14 @@
 +
 +typedef union _MACHTTRANSMIT_SETTING {
 +	struct  {
-+		unsigned short	MCS:7;  // MCS
-+		unsigned short	BW:1;   //channel bandwidth 20MHz or 40 MHz
++		unsigned short	MCS:6;  // MCS
++		unsigned short	ldpc:1;
++		unsigned short	BW:2;   //channel bandwidth 20MHz or 40 MHz
 +		unsigned short	ShortGI:1;
-+		unsigned short	STBC:2; //SPACE
-+		unsigned short	rsv:3;
-+		unsigned short	MODE:2; // Use definition MODE_xxx.
++		unsigned short	STBC:1; //SPACE
++		unsigned short	eTxBF:1;
++		unsigned short	iTxBF:1;
++		unsigned short	MODE:3; // Use definition MODE_xxx.
 +	} field;
 +	unsigned short	word;
 +} MACHTTRANSMIT_SETTING;
@@ -339,7 +341,7 @@
  	luaL_register(L, NULL, R_common);
 --- /dev/null
 +++ b/iwinfo_ra.c
-@@ -0,0 +1,1023 @@
+@@ -0,0 +1,982 @@
 +#include "iwinfo.h"
 +#include "iwinfo_ra.h"
 +#include "iwinfo_wext.h"
@@ -530,14 +532,6 @@
 +	return 0;
 +}
 +
-+int is_rausb(const char *ifname)
-+{
-+	if (!strncmp(ifname, "rausb", 5))
-+		return 1;
-+
-+	return 0;
-+}
-+
 +static int ra_ioctl(const char *ifname, int cmd, struct iwreq *wrq)
 +{
 +	if (!strncmp(ifname, "mon.", 4))
@@ -603,12 +597,6 @@
 +
 +int ra_get_mode(const char *ifname, int *buf)
 +{
-+	if (is_rausb(ifname))
-+	{
-+		*buf = IWINFO_OPMODE_CLIENT;
-+		return 0;
-+	}
-+
 +	if (strncmp(ifname, "ra", 2) == 0)
 +		*buf = IWINFO_OPMODE_MASTER;
 +	else if (strncmp(ifname, "apcli", 5) == 0)
@@ -687,9 +675,6 @@
 +{
 +	struct iwreq wrq;
 +
-+	if (is_rausb(ifname))
-+		return wext_get_frequency(ifname, buf);
-+
 +	if (ra_ioctl(ifname, SIOCGIWFREQ, &wrq) >= 0)
 +	{
 +		*buf = ra_freq2mhz(&wrq.u.freq);
@@ -755,8 +740,6 @@
 +int ra_get_quality(const char *ifname, int *buf)
 +{
 +	int tmp;
-+	if (is_rausb(ifname))
-+		return wext_get_quality(ifname, buf);
 +
 +	if (ra_get_signal(ifname, &tmp) == 0)
 +		*buf = 100 - (tmp / -95 * 100);
@@ -768,9 +751,6 @@
 +
 +int ra_get_quality_max(const char *ifname, int *buf)
 +{
-+	if (is_rausb(ifname))
-+		return wext_get_quality_max(ifname, buf);
-+
 +	*buf = 100;
 +	return 0;
 +}
@@ -964,60 +944,48 @@
 +	if (!strncmp(ifname, "apcli", 5))
 +		return -1;
 +
-+	if (is_rausb(ifname))
-+		return -1;
-+
 +	char table[8192];
 +
++	strcpy(wrq.ifr_ifrn.ifrn_name, ifname);
 +	wrq.u.data.pointer = (caddr_t)&table;
 +	wrq.u.data.flags = 0;
 +
 +	ret = ra_ioctl(ifname, RTPRIV_IOCTL_GET_MAC_TABLE_STRUCT, &wrq);
 +	if (ret < 0)
 +	{
-+		printf("assoclist ioctl fails\n");
++		fprintf(stderr, "assoclist ioctl fails\n");
 +		return -1;
 +	}
 +
 +	RT_802_11_MAC_TABLE *a = &table;
 +
-+	char iface[4];
-+
 +	*len = a->Num * sizeof(struct iwinfo_assoclist_entry);
 +
 +	for (i = 0; i < a->Num; i++)
 +	{
 +		RT_802_11_MAC_ENTRY *pe = &(a->Entry[i]);
 +		memset(&entry, 0, sizeof(entry));
-+		memset(&iface, 0, sizeof(iface));
-+		if (is_5g(ifname))
-+			sprintf(iface, "ra"MIDFIX5G"%d", pe->ApIdx);
-+		else
-+			sprintf(iface, "ra%d", pe->ApIdx);
 +
-+		if (strncmp(iface, ifname, sizeof(iface)) == 0)
-+		{
-+			entry.signal = ((int)(pe->AvgRssi0) + (int)(pe->AvgRssi1)) / 2;
++		entry.signal = ((int)(pe->AvgRssi0) + (int)(pe->AvgRssi1)) / 2;
 +
-+			entry.noise = -95;
-+			entry.inactive = pe->ConnectedTime * 1000;
++		entry.noise = -95;
++		entry.inactive = pe->ConnectedTime * 1000;
 +
-+			memcpy(&entry.mac, &pe->Addr, sizeof(entry.mac));
++		memcpy(&entry.mac, &pe->Addr, sizeof(entry.mac));
 +
-+			entry.tx_packets = 0;
-+			entry.rx_packets = 0;
++		entry.tx_packets = 0;
++		entry.rx_packets = 0;
 +
-+			entry.tx_rate.rate = getRate(pe->TxRate);
-+			entry.tx_rate.mcs = pe->TxRate.field.MCS;
-+			entry.tx_rate.is_40mhz = pe->TxRate.field.BW;
-+			entry.tx_rate.is_short_gi = pe->TxRate.field.ShortGI;
++		entry.tx_rate.rate = getRate(pe->TxRate);
++		entry.tx_rate.mcs = pe->TxRate.field.MCS;
++		entry.tx_rate.is_40mhz = pe->TxRate.field.BW;
++		entry.tx_rate.is_short_gi = pe->TxRate.field.ShortGI;
 +
-+			entry.rx_rate = entry.tx_rate;
++		entry.rx_rate = entry.tx_rate;
 +
-+			memcpy(&buf[bl], &entry, sizeof(struct iwinfo_assoclist_entry));
++		memcpy(&buf[bl], &entry, sizeof(struct iwinfo_assoclist_entry));
 +
-+			bl += sizeof(struct iwinfo_assoclist_entry);
-+		}
++		bl += sizeof(struct iwinfo_assoclist_entry);
 +
 +		*len = bl;
 +	}
@@ -1158,9 +1126,6 @@
 +
 +	int len_a, line_len;
 +
-+	if (is_rausb(ifname))
-+		return wext_get_scanlist(ifname, buf, len);
-+
 +	iwpriv_set(ifname, "SiteSurvey", "1");
 +	sleep(3);
 +
@@ -1214,9 +1179,6 @@
 +	int i, bl;
 +	bl = 0;
 +
-+	if (is_rausb(ifname))
-+		return wext_get_freqlist(ifname, buf, len);
-+
 +	if (is_5g(ifname)) {
 +		for (i=0; i<ARRAY_SIZE(CH5G); ++i) {
 +			entry.mhz = 5000 + 5 * CH5G[i];
@@ -1285,8 +1247,6 @@
 +int ra_get_hwmodelist(const char *ifname, int *buf)
 +{
 +	char data[10];
-+	if (is_rausb(ifname))
-+		return wext_get_hwmodelist(ifname, buf);
 +
 +	if (ra_oid_ioctl(ifname, RT_OID_VERSION_INFO, data, sizeof(data)) < 0)
 +		return -1;
@@ -1294,6 +1254,7 @@
 +	{
 +		*buf |= IWINFO_80211_A;
 +		*buf |= IWINFO_80211_N;
++		*buf |= IWINFO_80211_AC;
 +	}
 +	else
 +	{
@@ -1314,11 +1275,6 @@
 +int ra_get_mbssid_support(const char *ifname, int *buf)
 +{
 +	char data[10];
-+	if (is_rausb(ifname))
-+	{
-+		*buf = 0;
-+		return 0;
-+	}
 +
 +	if (ra_oid_ioctl(ifname, RT_OID_VERSION_INFO, data, sizeof(data)) < 0)
 +		return -1;
@@ -1326,28 +1282,33 @@
 +	return 0;
 +}
 +
++int iwinfo_hardware_id_from_mtd(struct iwinfo_hardware_id *id);
++
 +int ra_get_hardware_id(const char *ifname, char *buf)
 +{
 +	struct iwinfo_hardware_id *id = (struct iwinfo_hardware_id *)buf;
 +	memset(id, 0, sizeof(struct iwinfo_hardware_id));
 +	char data[10];
-+	if (ra_oid_ioctl(ifname, RT_OID_VERSION_INFO, data, sizeof(data)) < 0 && !is_rausb(ifname))
++	if (ra_oid_ioctl(ifname, RT_OID_VERSION_INFO, data, sizeof(data)) < 0)
 +		return -1;
-+	id->vendor_id = 0x1814;
-+	id->device_id = 0x7615;
-+	id->subsystem_device_id = 0x0;
-+	id->subsystem_vendor_id = 0x1814;
-+
-+	return (id->vendor_id > 0 && id->device_id > 0) ? 0 : -1;
++	return iwinfo_hardware_id_from_mtd(id);
 +}
 +
++struct iwinfo_hardware_entry * iwinfo_hardware(struct iwinfo_hardware_id *id);
++
 +int ra_get_hardware_name(const char *ifname, char *buf)
 +{
-+	char data[10];
++	struct iwinfo_hardware_id id;
++	struct iwinfo_hardware_entry *e;
 +
-+	if (ra_oid_ioctl(ifname, RT_OID_VERSION_INFO, data, sizeof(data)) < 0)
++	if (ra_get_hardware_id(ifname, (char *)&id))
++		return -1;
++
++	e = iwinfo_hardware(&id);
++	if (!e)
 +		return -1;
-+	sprintf(buf, "MT7615");
++
++	strcpy(buf, e->device_name);
 +
 +	return 0;
 +}
@@ -1507,7 +1468,7 @@
  	$(CC) $(IWINFO_CFLAGS) $(FPIC) -c -o $@ $<
 --- a/hardware.txt
 +++ b/hardware.txt
-@@ -173,6 +173,34 @@
+@@ -173,6 +173,36 @@
  0x1814 0x3662 0x1814 0x000d    0      0  "Ralink"   "Rt3662"
  0x1814 0x3883 0x1814 0x000d    0      0  "Ralink"   "Rt3883"
  0x1814 0x5350 0x1814 0x000f    0      0  "Ralink"   "Rt5350"
@@ -1538,7 +1499,21 @@
 +0x1814 0x7615 0x1814 0x0000    0      0  "Mediatek" "MT7615"
 +0x1814 0x7615 0x1814 0xffff    0      0  "Mediatek" "MT7615"
 +0x1814 0x7615 0x1814 0x7615    0      0  "Mediatek" "MT7615"
++
++0x14c3 0x7615 0x14c3 0x0000    0      0  "MediaTek" "MT7615E"
 +
  0x11ab 0x2a55 0x11ab 0x0000    0      0  "Marvell"  "88W8864"
  0x02df 0x9135 0x0000 0x0000    0      0  "Marvell"  "88W8887"
  0x11ab 0x2b40 0x11ab 0x0000    0      0  "Marvell"  "88W8964"
+--- a/iwinfo_utils.c
++++ b/iwinfo_utils.c
+@@ -259,7 +259,8 @@ int iwinfo_hardware_id_from_mtd(struct i
+ 
+ 				/* subsystem from EEPROM_NIC_CONF0_RF_TYPE */
+ 				id->subsystem_device_id = (bc[off + 0x1a] & 0x0f00) >> 8;
+-			} else if ((bc[off] == 0x7620) || (bc[off] == 0x2076) ||
++			} else if ((bc[off] == 0x7615) || (bc[off] == 0x1576) ||
++			           (bc[off] == 0x7620) || (bc[off] == 0x2076) ||
+ 			           (bc[off] == 0x7628) || (bc[off] == 0x2876) ||
+ 			           (bc[off] == 0x7688) || (bc[off] == 0x8876)) {
+ 				/* vendor: MediaTek */

From 49e57aaf6514fe4a34bd0e324abba407274f0dbb Mon Sep 17 00:00:00 2001
From: jjm2473 <1129525450@qq.com>
Date: Sat, 28 Nov 2020 13:45:03 +0800
Subject: [PATCH 04/20] mt7615: clean code

---
 package/feeds/custom/mt7615d/Makefile         |  1 -
 .../src/mt_wifi/embedded/include/cfg80211extr.h  |  2 +-
 .../mt7615d/src/mt_wifi/include/os/rt_linux.h    |  1 +
 .../mt7615d/src/mt_wifi/os/linux/rt_profile.c    | 16 ++++++++--------
 4 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/package/feeds/custom/mt7615d/Makefile b/package/feeds/custom/mt7615d/Makefile
index 37bcccd118c..8fa98118ae4 100644
--- a/package/feeds/custom/mt7615d/Makefile
+++ b/package/feeds/custom/mt7615d/Makefile
@@ -148,7 +148,6 @@ PKG_KCONFIG:= \
 	THIRD_IF_EEPROM_EFUSE \
 	RT_THIRD_CARD_EEPROM \
 	SPECTRUM_SUPPORT \
-	MULTI_PROFILE_SUPPORT \
 	PRE_CAL_TRX_SET1_SUPPORT \
 	MWDS \
 	MCAST_RATE_SPECIFIC \
diff --git a/package/feeds/custom/mt7615d/src/mt_wifi/embedded/include/cfg80211extr.h b/package/feeds/custom/mt7615d/src/mt_wifi/embedded/include/cfg80211extr.h
index b1b643b6be2..b7bb693578c 100644
--- a/package/feeds/custom/mt7615d/src/mt_wifi/embedded/include/cfg80211extr.h
+++ b/package/feeds/custom/mt7615d/src/mt_wifi/embedded/include/cfg80211extr.h
@@ -122,7 +122,7 @@ CFG80211_Scaning((VOID *)__pAd, __BssIdx, __ChanId, __pFrame,			\
 #define P2P_NOA_TX_ON    0x01
 #define P2P_NOA_RX_ON    0x02
 
-#define WLAN_AKM_SUITE_8021X		0x000FAC01
+//#define WLAN_AKM_SUITE_8021X		0x000FAC01
 #define WDEV_NOT_FOUND				-1
 
 
diff --git a/package/feeds/custom/mt7615d/src/mt_wifi/include/os/rt_linux.h b/package/feeds/custom/mt7615d/src/mt_wifi/include/os/rt_linux.h
index 42804616e66..4ffa7e80458 100644
--- a/package/feeds/custom/mt7615d/src/mt_wifi/include/os/rt_linux.h
+++ b/package/feeds/custom/mt7615d/src/mt_wifi/include/os/rt_linux.h
@@ -801,6 +801,7 @@ void linux_pci_unmap_single(void *handle, ra_dma_addr_t dma_addr, size_t size, i
 #define PCI_MAP_SINGLE_DEV(_pAd, _ptr, _size, _sd_idx, _dir)				\
 	linux_pci_map_single(((POS_COOKIE)(_pAd->OS_Cookie))->pDev, _ptr, _size, _sd_idx, _dir)
 
+#undef DMA_MAPPING_ERROR
 #define DMA_MAPPING_ERROR(_handle, _ptr)	\
 	dma_mapping_error(&((struct pci_dev *)(_handle))->dev, _ptr)
 
diff --git a/package/feeds/custom/mt7615d/src/mt_wifi/os/linux/rt_profile.c b/package/feeds/custom/mt7615d/src/mt_wifi/os/linux/rt_profile.c
index 38ca78054ee..29f532ee0ed 100644
--- a/package/feeds/custom/mt7615d/src/mt_wifi/os/linux/rt_profile.c
+++ b/package/feeds/custom/mt7615d/src/mt_wifi/os/linux/rt_profile.c
@@ -758,14 +758,14 @@ NDIS_STATUS	RTMPReadParametersHook(RTMP_ADAPTER *pAd)
 					buf_size = srcf.fsize  + 1;
 				}
 #endif /* OS_ABL_SUPPORT */
-					retval =os_file_read(srcf, buffer, buf_size - 1);
-					if (retval > 0)
-					{
-						RTMPSetProfileParameters(pAd, buffer);
-						retval = NDIS_STATUS_SUCCESS;
-					}
-					else
-						MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_ERROR, ("Read file \"%s\" failed(errCode=%d)!\n", src, retval));
+				retval =os_file_read(srcf, buffer, buf_size - 1);
+				if (retval > 0)
+				{
+					RTMPSetProfileParameters(pAd, buffer);
+					retval = NDIS_STATUS_SUCCESS;
+				}
+				else
+					MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_ERROR, ("Read file \"%s\" failed(errCode=%d)!\n", src, retval));
 
 				if (os_file_close(srcf) != 0)
 				{

From 6cb66b6106818ab2c28d968b698632f7bb31bee4 Mon Sep 17 00:00:00 2001
From: jjm2473 <1129525450@qq.com>
Date: Sat, 28 Nov 2020 13:49:00 +0800
Subject: [PATCH 05/20] k2p: wireless interface should not add to bridge, wifi
 system will handle this

---
 target/linux/ramips/mt7621/base-files/etc/board.d/02_network | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/target/linux/ramips/mt7621/base-files/etc/board.d/02_network b/target/linux/ramips/mt7621/base-files/etc/board.d/02_network
index aaae9ddb36f..9e5f7ae02f1 100755
--- a/target/linux/ramips/mt7621/base-files/etc/board.d/02_network
+++ b/target/linux/ramips/mt7621/base-files/etc/board.d/02_network
@@ -67,7 +67,7 @@ ramips_setup_interfaces()
 	xiaoyu,xy-c5)
 		ucidef_add_switch "switch0" \
 			"0:lan" "1:lan" "2:lan" "3:lan" "4:wan" "6@eth0"
-		ucidef_set_interface_lan "eth0.1 ra0 rax0"
+		ucidef_set_interface_lan "eth0.1"
 		;;
 	ubnt,edgerouter-x)
 		ucidef_set_interfaces_lan_wan "eth1 eth2 eth3 eth4" "eth0"

From 91ca9ee481c84556e4d427d9413f49c87bab4e89 Mon Sep 17 00:00:00 2001
From: jjm2473 <1129525450@qq.com>
Date: Sun, 29 Nov 2020 00:32:49 +0800
Subject: [PATCH 06/20] mt7615: adapt for modern luci

---
 .../files/lib/netifd/wireless/mt_dbdc.sh      | 36 ++++----
 .../drivers/mt7615d/files/lib/wifi/mt_dbdc.sh | 89 +++++++++----------
 .../utils/iwinfo/patches/001-ralink.patch     |  8 +-
 3 files changed, 66 insertions(+), 67 deletions(-)

diff --git a/package/feeds/custom/mt7615d/files/lib/netifd/wireless/mt_dbdc.sh b/package/feeds/custom/mt7615d/files/lib/netifd/wireless/mt_dbdc.sh
index 5c1072f7288..91ca9408679 100644
--- a/package/feeds/custom/mt7615d/files/lib/netifd/wireless/mt_dbdc.sh
+++ b/package/feeds/custom/mt7615d/files/lib/netifd/wireless/mt_dbdc.sh
@@ -68,17 +68,17 @@ drv_mt_dbdc_init_device_config() {
 drv_mt_dbdc_init_iface_config() { 
 	config_add_boolean disabled
 	config_add_string mode bssid ssid encryption
-	config_add_boolean hidden isolated doth ieee80211r
+	config_add_boolean hidden isolate doth ieee80211r
 	config_add_string key key1 key2 key3 key4
 	config_add_string wps
 	config_add_string pin
-	config_add_string macpolicy
+	config_add_string macfilter
 	config_add_array maclist
 	
 	config_add_boolean wds
 	config_add_int max_listen_int
 	config_add_int dtim_period
-	config_add_int rssikick rssiassoc
+	config_add_int disassoc_low_ack rssiassoc
 	config_add_string wdsenctype wdskey wdsphymode
 	config_add_int wdswepid wdstxmcs
 }
@@ -97,7 +97,7 @@ mt_dbdc_ap_vif_pre_config() {
 	local name="$1"
 
 	json_select config
-	json_get_vars disabled encryption key key1 key2 key3 key4 ssid mode wps pin hidden macpolicy
+	json_get_vars disabled encryption key key1 key2 key3 key4 ssid mode wps pin hidden macfilter
 	json_get_values maclist maclist
 	json_select ..
 	[ "$disabled" == "1" ] && return
@@ -106,7 +106,7 @@ mt_dbdc_ap_vif_pre_config() {
 
 	#MAC过滤方式相关设定 由于编号问题......我扔在这了......
 	ra_maclist="${maclist// /;};"
-	case "$macpolicy" in
+	case "$macfilter" in
 	allow)
 		echo "Interface ${ifname} has MAC Policy.Allow list:${ra_maclist}"
 		echo "AccessPolicy${ApBssidNum}=1" >> $RTWIFI_PROFILE_PATH
@@ -231,7 +231,7 @@ mt_dbdc_ap_vif_post_config() {
 	local name="$1"
 
 	json_select config
-	json_get_vars disabled encryption key key1 key2 key3 key4 ssid mode wps pin isolated doth hidden rssikick rssiassoc ieee80211r
+	json_get_vars disabled encryption key key1 key2 key3 key4 ssid mode wps pin isolate doth hidden disassoc_low_ack rssiassoc ieee80211r
 	json_select ..
 
 	[ "$disabled" == "1" ] && return
@@ -243,7 +243,7 @@ mt_dbdc_ap_vif_post_config() {
 
 	ifconfig $ifname up
 	echo "Interface $ifname now up."
-	mt_cmd iwpriv $ifname set NoForwarding=${isolated:-0}
+	mt_cmd iwpriv $ifname set NoForwarding=${isolate:-0}
 	mt_cmd iwpriv $ifname set IEEE80211H=${doth:-0}
 	if [ "$wps" == "pbc" ]  && [ "$encryption" != "none" ]; then
 		echo "Enable WPS for ${ifname}."
@@ -254,7 +254,7 @@ mt_dbdc_ap_vif_post_config() {
 	else
 		mt_cmd iwpriv $ifname set WscConfMode=0
 	fi
-	[ -n "$rssikick" ]  && [ "$rssikick" != "0" ] && mt_cmd iwpriv $ifname set KickStaRssiLow=$rssikick
+	[ -n "$disassoc_low_ack" ]  && [ "$disassoc_low_ack" != "0" ] && mt_cmd iwpriv $ifname set KickStaRssiLow=$disassoc_low_ack
 	[ -n "$rssiassoc" ]  && [ "$rssiassoc" != "0" ] && mt_cmd iwpriv $ifname set AssocReqRssiThres=$rssiassoc
 	[ -n "$ieee80211r" ]  && [ "$ieee80211r" != "0" ] && mt_cmd iwpriv $ifname set ftenable=1
 	wireless_add_vif "$name" "$ifname"
@@ -298,12 +298,12 @@ mt_dbdc_vif_down() {
 	killall -9 -q apcli_2g
 	killall -9 -q apcli_5g
 	case "$phy_name" in
-		rax)
+		rax0)
 			for vif in ra0 ra1 ra2 ra3 ra4 ra5 ra6 ra7 wds0 wds1 wds2 wds3 apcli0; do
 				[ "$(get_if_stat $vif)" != "down" ] && ifconfig $vif down && echo $vif
 			done
 		;;
-		ra)
+		ra0)
 			for vif in rax0 rax1 rax2 rax3 rax4 rax5 rax6 rax7 wdsx0 wdsx1 wdsx2 wdsx3 apclix0; do
 				[ "$(get_if_stat $vif)" != "down" ] && ifconfig $vif down && echo $vif
 			done
@@ -318,14 +318,14 @@ drv_mt_dbdc_cleanup() {
 drv_mt_dbdc_teardown() {
 	phy_name=${1}
 	case "$phy_name" in
-		ra)
+		ra0)
 			killall -9 -q apcli_2g
 			for vif in ra0 ra1 ra2 ra3 ra4 ra5 ra6 ra7 wds0 wds1 wds2 wds3 apcli0; do
 				iwpriv $vif set DisConnectAllSta=1
 				[ -d "/sys/class/net/$vif" ] && ifconfig $vif down
 			done
 		;;
-		rax)
+		rax0)
 			killall -9 -q apcli_5g
 			for vif in rax0 rax1 rax2 rax3 rax4 rax5 rax6 rax7 wdsx0 wdsx1 wdsx2 wdsx3 apclix0; do
 				iwpriv $vif set DisConnectAllSta=1
@@ -339,9 +339,9 @@ drv_mt_dbdc_teardown() {
 drv_mt_dbdc_setup() {
 	json_select config
 	json_get_vars main_if macaddr channel mode hwmode wmm htmode \
-		txpower country macpolicy maclist greenap \
+		txpower country macfilter maclist greenap \
 		diversity frag rts txburst distance hidden \
-		disabled maxassoc macpolicy maclist noscan ht_coex smart #device所有配置项
+		disabled maxassoc noscan ht_coex smart #device所有配置项
 		
 	json_get_vars \
 			ldpc:1 \
@@ -376,7 +376,7 @@ drv_mt_dbdc_setup() {
 	phy_name=${1}
 	wireless_set_data phy=${phy_name}
 	case "$phy_name" in
-		ra)
+		ra0)
 			WirelessMode=9
 			APCLI_IF="apcli0"
 			APCLI_APCTRL="apcli_2g"
@@ -386,7 +386,7 @@ drv_mt_dbdc_setup() {
 			RTWIFI_CMD_PATH="${RTWIFI_PROFILE_DIR}mt_dbdc_cmd_2g.sh"
 			RTWIFI_CMD_OPATH="${RTWIFI_PROFILE_DIR}mt_dbdc_cmd_5g.sh"
 		;;
-		rax)
+		rax0)
 			WirelessMode=14
 			APCLI_IF="apclix0"
 			APCLI_APCTRL="apcli_5g"
@@ -846,7 +846,7 @@ EOF
 	sleep 1
 
 #Start root device
-	[ "$phy_name" == "rax" ] && ifconfig ra0 up
+	[ "$phy_name" == "rax0" ] && ifconfig ra0 up
 #restore interfaces
 	[ -z "$RESET_IF" ] || {
 		for i in $RESET_IF
@@ -865,7 +865,7 @@ EOF
 	stacount=0
 	for_each_interface "sta" mt_dbdc_sta_vif_connect
 
-	[ "$phy_name" == "rax" ] && [ "$RA_MAIN_UP" == "down" ] && ifconfig ra0 down
+	[ "$phy_name" == "rax0" ] && [ "$RA_MAIN_UP" == "down" ] && ifconfig ra0 down
 
 #重启HWNAT
 	[ -d /sys/module/hw_nat ] && {
diff --git a/package/feeds/custom/mt7615d/files/lib/wifi/mt_dbdc.sh b/package/feeds/custom/mt7615d/files/lib/wifi/mt_dbdc.sh
index 1de506a19cf..0ab5c92892c 100644
--- a/package/feeds/custom/mt7615d/files/lib/wifi/mt_dbdc.sh
+++ b/package/feeds/custom/mt7615d/files/lib/wifi/mt_dbdc.sh
@@ -25,52 +25,51 @@ mt_get_first_if_mac() {
 detect_mt_dbdc() {
 	local macaddr
 	[ -d /sys/module/mt_wifi ] && [ $( grep -c ra0 /proc/net/dev) -eq 1 ] && {
-		for phyname in ra rax; do
-		config_get type $phyname type
-		macaddr=$(mt_get_first_if_mac)
-		[ "$type" == "mt_dbdc" ] || {
-			case $phyname in
-				ra)
-					hwmode=11g
-					htmode=HT20
-					pb_smart=1
-					noscan=0
-					ssid="OpenWRT-2.4G-$(echo $macaddr | awk -F ":" '{print $4""$5""$6 }'| tr a-z A-Z)"
-					;;
-				rax)
-					hwmode=11a
-					htmode=VHT80
-					macaddr=$(mt_get_first_if_mac)
-					ssid="OpenWRT-5G-$(maccalc add $macaddr 3145728 | awk -F ":" '{print $4""$5""$6 }'| tr a-z A-Z)"
-					pb_smart=0
-					noscan=1
-					;;
-			esac
-			
-#		[ -n "$macaddr" ] && {
-#			dev_id="set wireless.${phyname}.macaddr=${macaddr}"
-#		}
-		uci -q batch <<-EOF
-			set wireless.${phyname}=wifi-device
-			set wireless.${phyname}.type=mt_dbdc
-			set wireless.${phyname}.hwmode=$hwmode
-			set wireless.${phyname}.channel=auto
-			set wireless.${phyname}.txpower=100
-			set wireless.${phyname}.htmode=$htmode
-			set wireless.${phyname}.country=CN
-			set wireless.${phyname}.txburst=1
-			set wireless.${phyname}.noscan=$noscan
-			set wireless.${phyname}.smart=$pb_smart
+		for phyname in ra0 rax0; do
+			config_get type $phyname type
+			macaddr=$(mt_get_first_if_mac)
+			[ "$type" == "mt_dbdc" ] || {
+				case $phyname in
+					ra0)
+						hwmode=11g
+						htmode=HT20
+						pb_smart=1
+						noscan=0
+						ssid="OpenWRT-2.4G-$(echo $macaddr | awk -F ":" '{print $4""$5""$6 }'| tr a-z A-Z)"
+						;;
+					rax0)
+						hwmode=11a
+						htmode=VHT80
+						ssid="OpenWRT-5G-$(maccalc add $macaddr 3145728 | awk -F ":" '{print $4""$5""$6 }'| tr a-z A-Z)"
+						pb_smart=0
+						noscan=1
+						;;
+				esac
+				
+#				[ -n "$macaddr" ] && {
+#					dev_id="set wireless.${phyname}.macaddr=${macaddr}"
+#				}
+				uci -q batch <<-EOF
+					set wireless.${phyname}=wifi-device
+					set wireless.${phyname}.type=mt_dbdc
+					set wireless.${phyname}.hwmode=$hwmode
+					set wireless.${phyname}.channel=auto
+					set wireless.${phyname}.txpower=100
+					set wireless.${phyname}.htmode=$htmode
+					set wireless.${phyname}.country=CN
+					set wireless.${phyname}.txburst=1
+					set wireless.${phyname}.noscan=$noscan
+					set wireless.${phyname}.smart=$pb_smart
 
-			set wireless.default_${phyname}=wifi-iface
-			set wireless.default_${phyname}.device=${phyname}
-			set wireless.default_${phyname}.network=lan
-			set wireless.default_${phyname}.mode=ap
-			set wireless.default_${phyname}.ssid=${ssid}
-			set wireless.default_${phyname}.encryption=none
-EOF
-		uci -q commit wireless
-		}
+					set wireless.default_${phyname}=wifi-iface
+					set wireless.default_${phyname}.device=${phyname}
+					set wireless.default_${phyname}.network=lan
+					set wireless.default_${phyname}.mode=ap
+					set wireless.default_${phyname}.ssid=${ssid}
+					set wireless.default_${phyname}.encryption=none
+				EOF
+				uci -q commit wireless
+			}
 		done
 	}
 }
diff --git a/package/network/utils/iwinfo/patches/001-ralink.patch b/package/network/utils/iwinfo/patches/001-ralink.patch
index 248f837e52f..d554a0c8bbf 100644
--- a/package/network/utils/iwinfo/patches/001-ralink.patch
+++ b/package/network/utils/iwinfo/patches/001-ralink.patch
@@ -995,18 +995,18 @@
 +int ra_get_txpwrlist(const char *ifname, char *buf, int *len)
 +{
 +	struct iwinfo_txpwrlist_entry entry;
-+	uint8_t dbm[11] = {0, 6, 8, 10, 12, 14, 16, 18, 20};
-+	uint8_t mw[11] = {1, 3, 6, 10, 15, 25, 39, 63, 100};
++	uint8_t dbm[9] = {0, 6, 8, 10, 12, 14, 16, 18, 20};
++	uint8_t mw[9] = {1, 3, 6, 10, 15, 25, 39, 63, 100};
 +	int i;
 +
-+	for (i = 0; i < 11; i++)
++	for (i = 0; i < 9; i++)
 +	{
 +		entry.dbm = dbm[i];
 +		entry.mw = mw[i];
 +		memcpy(&buf[i * sizeof(entry)], &entry, sizeof(entry));
 +	}
 +
-+	*len = 11 * sizeof(entry);
++	*len = 9 * sizeof(entry);
 +	return 0;
 +}
 +

From d5b2cced4bee30d6f0dded59ab5bcab1108246dd Mon Sep 17 00:00:00 2001
From: jjm2473 <1129525450@qq.com>
Date: Mon, 30 Nov 2020 12:45:08 +0800
Subject: [PATCH 07/20] mt7615: fix Makefile, conflicts with luci-app-mtwifi

---
 package/feeds/custom/mt7615d/src/mt_wifi_ap/Makefile | 2 ++
 package/feeds/custom/luci-app-mtwifi/Makefile                | 2 +-
 2 files changed, 3 insertions(+), 1 deletion(-)

diff --git a/package/feeds/custom/mt7615d/src/mt_wifi_ap/Makefile b/package/feeds/custom/mt7615d/src/mt_wifi_ap/Makefile
index 2ec14092023..a01f788cd3a 100644
--- a/package/feeds/custom/mt7615d/src/mt_wifi_ap/Makefile
+++ b/package/feeds/custom/mt7615d/src/mt_wifi_ap/Makefile
@@ -487,6 +487,7 @@ ifeq ($(CONFIG_HOSTAPD_MAP_SUPPORT),y)
 endif
 
 #ENTERPRISE_AP
+ifeq ($(CONFIG_CFG80211_SUPPORT),y)
 ifneq ($(CONFIG_HOSTAPD_MAP_SUPPORT),y)
 	EXTRA_CFLAGS += -DHOSTAPD_11R_SUPPORT
 	EXTRA_CFLAGS += -DMBSS_DTIM_SUPPORT
@@ -501,6 +502,7 @@ ifneq ($(CONFIG_HOSTAPD_MAP_SUPPORT),y)
 	endif
 
 endif
+endif
 
 #CFG
 ifeq ($(CONFIG_CFG80211_SUPPORT),y)
diff --git a/package/feeds/custom/luci-app-mtwifi/Makefile b/package/feeds/custom/luci-app-mtwifi/Makefile
index fa3ed725fc2..dfeb286370d 100644
--- a/package/feeds/custom/luci-app-mtwifi/Makefile
+++ b/package/feeds/custom/luci-app-mtwifi/Makefile
@@ -4,7 +4,7 @@ PKG_LICENSE:=GPLv2
 PKG_MAINTAINER:=Hua Shao <nossiac@163.com>
 
 LUCI_TITLE:=LuCI support for mt wifi driver
-LUCI_DEPENDS:=@TARGET_ramips +mt_wifi
+LUCI_DEPENDS:=@TARGET_ramips +mt_wifi @!PACKAGE_kmod-mt7615d
 LUCI_PKGARCH:=all
 PKG_VERSION:=1
 PKG_RELEASE:=16

From 88ee0531a7a0ac003f336ce5c7695b11ce8ac4f8 Mon Sep 17 00:00:00 2001
From: jjm2473 <1129525450@qq.com>
Date: Mon, 30 Nov 2020 13:22:44 +0800
Subject: [PATCH 08/20] mt_wifi: conflicts with mt7615d

---
 package/feeds/custom/mt_wifi/Makefile | 1 +
 1 file changed, 1 insertion(+)

diff --git a/package/feeds/custom/mt_wifi/Makefile b/package/feeds/custom/mt_wifi/Makefile
index 6b60be38888..57d8d6c932e 100644
--- a/package/feeds/custom/mt_wifi/Makefile
+++ b/package/feeds/custom/mt_wifi/Makefile
@@ -22,6 +22,7 @@ define Package/mt_wifi
   CATEGORY:=Network
   TITLE:=MTK wifi AP config
   DEPENDS:=@TARGET_ramips +wireless-tools
+  CONFLICTS:=kmod-mt7615d
   SUBMENU:=Wireless
 endef
 

From c5c9ee0e32b88bca9170296299f37cf82eaaeeaa Mon Sep 17 00:00:00 2001
From: jjm2473 <1129525450@qq.com>
Date: Mon, 30 Nov 2020 15:29:27 +0800
Subject: [PATCH 09/20] iwinfo: fix ra probe, scan list

---
 .../utils/iwinfo/patches/001-ralink.patch     | 27 ++++++++++---------
 1 file changed, 15 insertions(+), 12 deletions(-)

diff --git a/package/network/utils/iwinfo/patches/001-ralink.patch b/package/network/utils/iwinfo/patches/001-ralink.patch
index d554a0c8bbf..0e94c9e0526 100644
--- a/package/network/utils/iwinfo/patches/001-ralink.patch
+++ b/package/network/utils/iwinfo/patches/001-ralink.patch
@@ -341,7 +341,7 @@
  	luaL_register(L, NULL, R_common);
 --- /dev/null
 +++ b/iwinfo_ra.c
-@@ -0,0 +1,982 @@
+@@ -0,0 +1,985 @@
 +#include "iwinfo.h"
 +#include "iwinfo_ra.h"
 +#include "iwinfo_wext.h"
@@ -574,7 +574,9 @@
 +{
 +	unsigned char data[12];
 +	int version;
-+	if (ra_oid_ioctl(ifname, RT_OID_VERSION_INFO, data, sizeof(data)) >= 0)
++	if (strncmp(ifname, "ra", 2) && strncmp(ifname, "wds", 3) && strncmp(ifname, "apcli", 5))
++		return 0;
++	if (ra_oid_ioctl(ifname, RT_OID_VERSION_INFO, data, sizeof(data)) == 0)
 +	{
 +		data[1] = data[2];
 +		data[2] = data[4];
@@ -1026,7 +1028,7 @@
 +	if (strstr(sec, "WPA"))
 +	{
 +		enc->enabled = 1;
-+		if (strstr(sec, "WPA1PSKWPA2PSK"))
++		if (strstr(sec, "WPAPSKWPA2PSK"))
 +			enc->wpa_version = 3;
 +		else if (strstr(sec, "WPA2PSK"))
 +			enc->wpa_version = 2;
@@ -1039,7 +1041,7 @@
 +
 +		if (strstr(sec, "AES"))
 +			enc->pair_ciphers |= IWINFO_CIPHER_CCMP;
-+		else
++		if (strstr(sec, "TKIP"))
 +			enc->pair_ciphers |= IWINFO_CIPHER_TKIP;
 +
 +		enc->group_ciphers = enc->pair_ciphers;
@@ -1078,6 +1080,7 @@
 +	char ssid_str[128];
 +	int len;
 +
++	sp += 4; // skip No
 +	memcpy(site_channel, sp, 4);
 +	memcpy(site_ssid, sp + 4, 33);
 +	memcpy(site_bssid, sp + 37, 20);
@@ -1121,10 +1124,9 @@
 +{
 +	struct iwreq wrq;
 +	char data[8192];
-+	memset(data, 0, 32);
-+	char *sp, *op, *empty;
++	char *sp, *op, *empty, *end;
 +
-+	int len_a, line_len;
++	int line_len;
 +
 +	iwpriv_set(ifname, "SiteSurvey", "1");
 +	sleep(3);
@@ -1137,13 +1139,14 @@
 +	if (ra_ioctl(ifname, RTPRIV_IOCTL_GSITESURVEY, &wrq) >= 0)
 +	{
 +		struct iwinfo_scanlist_entry e;
-+		line_len = 4 + 33 + 20 + 23 + 9 + 7 + 7 + 3;
-+		if (wrq.u.data.length < 1)
++		// No  Ch  SSID                             BSSID               Security               Siganl(%)W-Mode  ExtCH  NT SSID_Len WPS DPID BcnRept
++		line_len = 4 + 4 + 33 + 20 + 23 + 9 + 8 + 7 + 3 + 9 + 4 + 5 + 7;
++		if (wrq.u.data.length < line_len + 3 + 10)
 +			return -1;
-+		op = sp = wrq.u.data.pointer + line_len + 2; // skip \n+\n
-+		len_a = strlen(op);
++		op = sp = wrq.u.data.pointer + line_len + 3 + 10; // skip \n+'Total=xxxx'+\n+HEADER+\n
++		end = sp + strlen(op);
 +		int i = 0;
-+		while (*sp && ((len_a - (sp - op)) >= 0))
++		while (*sp >= '0' && end > sp)
 +		{
 +			memset(&e, 0, sizeof(struct iwinfo_scanlist_entry));
 +

From 9abc0b54150900d0949c5bdc07c13b68b6f4972b Mon Sep 17 00:00:00 2001
From: jjm2473 <1129525450@qq.com>
Date: Tue, 1 Dec 2020 12:31:09 +0800
Subject: [PATCH 10/20] iwinfo: fix ra scan list

---
 .../utils/iwinfo/patches/001-ralink.patch     | 39 +++++++++++++------
 1 file changed, 27 insertions(+), 12 deletions(-)

diff --git a/package/network/utils/iwinfo/patches/001-ralink.patch b/package/network/utils/iwinfo/patches/001-ralink.patch
index 0e94c9e0526..5f2ae27eacd 100644
--- a/package/network/utils/iwinfo/patches/001-ralink.patch
+++ b/package/network/utils/iwinfo/patches/001-ralink.patch
@@ -341,7 +341,7 @@
  	luaL_register(L, NULL, R_common);
 --- /dev/null
 +++ b/iwinfo_ra.c
-@@ -0,0 +1,985 @@
+@@ -0,0 +1,1000 @@
 +#include "iwinfo.h"
 +#include "iwinfo_ra.h"
 +#include "iwinfo_wext.h"
@@ -1120,13 +1120,23 @@
 +	memcpy(e->ssid, site_ssid, len);
 +}
 +
++static char *next_line(char *sp) {
++	while (*sp != '\n' && *sp != '\0')
++		++sp;
++	if (*sp == '\n')
++		++sp; // skip \n
++	return sp;
++}
++
 +int ra_get_scanlist(const char *ifname, char *buf, int *len)
 +{
 +	struct iwreq wrq;
 +	char data[8192];
-+	char *sp, *op, *empty, *end;
++	char *sp, *empty, *end;
 +
-+	int line_len;
++	int line_len, i;
++
++	int is5g = is_5g(ifname);
 +
 +	iwpriv_set(ifname, "SiteSurvey", "1");
 +	sleep(3);
@@ -1140,22 +1150,27 @@
 +	{
 +		struct iwinfo_scanlist_entry e;
 +		// No  Ch  SSID                             BSSID               Security               Siganl(%)W-Mode  ExtCH  NT SSID_Len WPS DPID BcnRept
-+		line_len = 4 + 4 + 33 + 20 + 23 + 9 + 8 + 7 + 3 + 9 + 4 + 5 + 7;
++		line_len = 4 + 4 + 33 + 20 + 23 + 9 + 8 + 7 + 3 + 9; // WPS DPID may not present
 +		if (wrq.u.data.length < line_len + 3 + 10)
 +			return -1;
-+		op = sp = wrq.u.data.pointer + line_len + 3 + 10; // skip \n+'Total=xxxx'+\n+HEADER+\n
-+		end = sp + strlen(op);
-+		int i = 0;
++		sp = wrq.u.data.pointer;
++		for (i = 0; i < 3; ++i) {
++			// skip \n+'Total=xxxx'+\n+HEADER+\n
++			sp = next_line(sp);
++		}
++		end = sp + strlen(sp);
++		i = 0;
 +		while (*sp >= '0' && end > sp)
 +		{
 +			memset(&e, 0, sizeof(struct iwinfo_scanlist_entry));
 +
 +			fill_find_entry(sp, &e);
-+
-+			memcpy(&buf[i * sizeof(struct iwinfo_scanlist_entry)], &e, sizeof(struct iwinfo_scanlist_entry));
-+
-+			i++;
-+			sp += line_len + 1; // skip \n
++			if ((e.channel < 34) ^ is5g) {
++				memcpy(&buf[i * sizeof(struct iwinfo_scanlist_entry)], &e, sizeof(struct iwinfo_scanlist_entry));
++				i++;
++			}
++			sp += line_len;
++			sp = next_line(sp);
 +		}
 +		*len = i * sizeof(struct iwinfo_scanlist_entry);
 +		return 0;

From b52b00c100a7c228a64a1ecd5a7d654b3a0faf4c Mon Sep 17 00:00:00 2001
From: jjm2473 <1129525450@qq.com>
Date: Tue, 1 Dec 2020 15:35:55 +0800
Subject: [PATCH 11/20] mt7615: speed up wifi reload

---
 .../files/lib/netifd/wireless/mt_dbdc.sh      | 136 ++++++++++--------
 1 file changed, 76 insertions(+), 60 deletions(-)

diff --git a/package/feeds/custom/mt7615d/files/lib/netifd/wireless/mt_dbdc.sh b/package/feeds/custom/mt7615d/files/lib/netifd/wireless/mt_dbdc.sh
index 91ca9408679..8bec004353f 100644
--- a/package/feeds/custom/mt7615d/files/lib/netifd/wireless/mt_dbdc.sh
+++ b/package/feeds/custom/mt7615d/files/lib/netifd/wireless/mt_dbdc.sh
@@ -97,7 +97,7 @@ mt_dbdc_ap_vif_pre_config() {
 	local name="$1"
 
 	json_select config
-	json_get_vars disabled encryption key key1 key2 key3 key4 ssid mode wps pin hidden macfilter
+	json_get_vars disabled encryption key key1 key2 key3 key4 ssid mode wps pin isolate doth hidden disassoc_low_ack rssiassoc ieee80211r macfilter
 	json_get_values maclist maclist
 	json_select ..
 	[ "$disabled" == "1" ] && return
@@ -187,6 +187,23 @@ mt_dbdc_ap_vif_pre_config() {
 	ApK2Tp="${ApK2Tp}${K2Tp:-0};"
 	ApK3Tp="${ApK3Tp}${K3Tp:-0};"
 	ApK4Tp="${ApK4Tp}${K4Tp:-0};"
+
+	mt_cmd ifconfig $ifname up
+	mt_cmd echo "Interface $ifname now up."
+	mt_cmd iwpriv $ifname set NoForwarding=${isolate:-0}
+	mt_cmd iwpriv $ifname set IEEE80211H=${doth:-0}
+	if [ "$wps" == "pbc" ]  && [ "$encryption" != "none" ]; then
+		echo "Enable WPS for ${ifname}."
+		mt_cmd iwpriv $ifname set WscConfMode=4
+		mt_cmd iwpriv $ifname set WscConfStatus=2
+		mt_cmd iwpriv $ifname set WscMode=2
+		mt_cmd iwpriv $ifname set WscV2Support=0
+	else
+		mt_cmd iwpriv $ifname set WscConfMode=0
+	fi
+	[ -n "$disassoc_low_ack" ]  && [ "$disassoc_low_ack" != "0" ] && mt_cmd iwpriv $ifname set KickStaRssiLow=$disassoc_low_ack
+	[ -n "$rssiassoc" ]  && [ "$rssiassoc" != "0" ] && mt_cmd iwpriv $ifname set AssocReqRssiThres=$rssiassoc
+	[ -n "$ieee80211r" ]  && [ "$ieee80211r" != "0" ] && mt_cmd iwpriv $ifname set ftenable=1
 }
 
 mt_dbdc_wds_vif_pre_config() {
@@ -200,7 +217,8 @@ mt_dbdc_wds_vif_pre_config() {
 	json_select ..
 	[ "$disabled" == "1" ] && return
 	[ $WDSBssidNum -gt 3 ] && return
-	echo "Generating WDS config for interface wds${RTWIFI_IFPREFIX}${WDSBssidNum}"
+	ifname="wds${RTWIFI_IFPREFIX}${WDSBssidNum}"
+	echo "Generating WDS config for interface $ifname"
 	WDSEN=1
 	WDSList="${WDSList}${bssid};"
 	WDSEncType="${WDSEncType}${wdsenctype};"
@@ -209,6 +227,30 @@ mt_dbdc_wds_vif_pre_config() {
 	WDSTxMCS="${WDSTxMCS}${wdstxmcs};"
 	echo "Wds${ApBssidNum}Key=${wdskey}" >> $RTWIFI_PROFILE_PATH #WDS Key
 	let WDSBssidNum+=1
+
+	mt_cmd ifconfig $ifname up
+	mt_cmd echo "WDS interface $ifname now up."
+}
+
+mt_dbdc_sta_vif_pre_config() {
+	local name="$1"
+
+	json_select config
+	json_get_vars disabled encryption key key1 key2 key3 key4 ssid mode bssid
+	json_select ..
+
+	[ $stacount -gt 1 ] && {
+		return
+	}
+
+	[ "$disabled" == "1" ] && return
+	let stacount+=1
+
+	mt_cmd ifconfig $APCLI_IF up
+	killall  $APCLI_APCTRL
+	[ ! -z "$key" ] && APCTRL_KEY_ARG="-k"
+	[ ! -z "$bssid" ] && APCTRL_BSS_ARG="-b $(echo $bssid | tr 'A-Z' 'a-z')"
+	mt_cmd $APCLI_APCTRL ra${RTWIFI_IFPREFIX}0 connect -s "$ssid" $APCTRL_BSS_ARG $APCTRL_KEY_ARG "$key"
 }
 
 mt_dbdc_wds_vif_post_config() {
@@ -221,10 +263,9 @@ mt_dbdc_wds_vif_post_config() {
 	[ $WDSBssidNum -gt 3 ] && return
 
 	ifname="wds${RTWIFI_IFPREFIX}${WDSBssidNum}"
-	ifconfig $ifname up
-	echo "WDS interface wds${RTWIFI_IFPREFIX}${WDSBssidNum} now up."
-	wireless_add_vif "$name" "$ifname"
 	let WDSBssidNum+=1
+
+	wireless_add_vif "$name" "$ifname"
 }
 
 mt_dbdc_ap_vif_post_config() {
@@ -235,36 +276,20 @@ mt_dbdc_ap_vif_post_config() {
 	json_select ..
 
 	[ "$disabled" == "1" ] && return
-	
+
 	[ $ApIfCNT -gt $RTWIFI_DEF_MAX_BSSID ] && return 
-	
+
 	ifname="ra${RTWIFI_IFPREFIX}${ApIfCNT}"
 	let ApIfCNT+=1
 
-	ifconfig $ifname up
-	echo "Interface $ifname now up."
-	mt_cmd iwpriv $ifname set NoForwarding=${isolate:-0}
-	mt_cmd iwpriv $ifname set IEEE80211H=${doth:-0}
-	if [ "$wps" == "pbc" ]  && [ "$encryption" != "none" ]; then
-		echo "Enable WPS for ${ifname}."
-		mt_cmd iwpriv $ifname set WscConfMode=4
-		mt_cmd iwpriv $ifname set WscConfStatus=2
-		mt_cmd iwpriv $ifname set WscMode=2
-		mt_cmd iwpriv $ifname set WscV2Support=0
-	else
-		mt_cmd iwpriv $ifname set WscConfMode=0
-	fi
-	[ -n "$disassoc_low_ack" ]  && [ "$disassoc_low_ack" != "0" ] && mt_cmd iwpriv $ifname set KickStaRssiLow=$disassoc_low_ack
-	[ -n "$rssiassoc" ]  && [ "$rssiassoc" != "0" ] && mt_cmd iwpriv $ifname set AssocReqRssiThres=$rssiassoc
-	[ -n "$ieee80211r" ]  && [ "$ieee80211r" != "0" ] && mt_cmd iwpriv $ifname set ftenable=1
 	wireless_add_vif "$name" "$ifname"
 }
 
-mt_dbdc_sta_vif_connect() {
+mt_dbdc_sta_vif_post_config() {
 	local name="$1"
 
 	json_select config
-	json_get_vars disabled encryption key key1 key2 key3 key4 ssid mode bssid
+	json_get_vars disabled
 	json_select ..
 
 	[ $stacount -gt 1 ] && {
@@ -272,20 +297,8 @@ mt_dbdc_sta_vif_connect() {
 	}
 
 	[ "$disabled" == "1" ] && return
-	[ -z "${RTWIFI_IFPREFIX}" ] && [ "$ApIfCNT" == "0" ] && {
-		#FIXME: need ra0 up before apcli0 start
-		ifconfig ra${RTWIFI_IFPREFIX}0 up
-		ifconfig $APCLI_IF up
-		iwpriv ra${RTWIFI_IFPREFIX}0 set DisConnectAllSta=1 2>/dev/null
-		ifconfig ra${RTWIFI_IFPREFIX}0 down
-	}
 	let stacount+=1
 
-	killall  $APCLI_APCTRL
-	[ ! -z "$key" ] && APCTRL_KEY_ARG="-k"
-	[ ! -z "$bssid" ] && APCTRL_BSS_ARG="-b $(echo $bssid | tr 'A-Z' 'a-z')"
-	mt_cmd $APCLI_APCTRL ra${RTWIFI_IFPREFIX}0 connect -s "$ssid" $APCTRL_BSS_ARG $APCTRL_KEY_ARG "$key"
-
 	wireless_add_vif "$name" "$APCLI_IF"
 }
 
@@ -321,14 +334,14 @@ drv_mt_dbdc_teardown() {
 		ra0)
 			killall -9 -q apcli_2g
 			for vif in ra0 ra1 ra2 ra3 ra4 ra5 ra6 ra7 wds0 wds1 wds2 wds3 apcli0; do
-				iwpriv $vif set DisConnectAllSta=1
+				# iwpriv $vif set DisConnectAllSta=1
 				[ -d "/sys/class/net/$vif" ] && ifconfig $vif down
 			done
 		;;
 		rax0)
 			killall -9 -q apcli_5g
 			for vif in rax0 rax1 rax2 rax3 rax4 rax5 rax6 rax7 wdsx0 wdsx1 wdsx2 wdsx3 apclix0; do
-				iwpriv $vif set DisConnectAllSta=1
+				# iwpriv $vif set DisConnectAllSta=1
 				[ -d "/sys/class/net/$vif" ] && ifconfig $vif down
 			done
 		;;
@@ -781,6 +794,10 @@ VideoTxLifeTimeMode=1
 EOF
 
 #接口配置生成
+#	STA模式
+	stacount=0
+	for_each_interface "sta" mt_dbdc_sta_vif_pre_config
+
 #	AP模式
 #	统一设置的内容:
 	ApEncrypType=""
@@ -795,6 +812,7 @@ EOF
 
 	for_each_interface "ap" mt_dbdc_ap_vif_pre_config
 
+	[ "$phy_name" == "ra0" ] && [ "$ApBssidNum" == "0" ] && mt_cmd ifconfig ra0 down
 #For DBDC profile merging......
 	while [ $ApBssidNum -lt $RTWIFI_DEF_MAX_BSSID ]
 	do
@@ -837,24 +855,28 @@ EOF
 #接口上线
 #加锁
 	echo "Pending..."
-	lock $WIFI_OP_LOCK
-	sleep 3
-	RA_MAIN_UP=$(get_if_stat ra0)
-	drv_mt_dbdc_teardown $phy_name
-	RESET_IF=$(mt_dbdc_vif_down $phy_name)
-	echo "MT_DBDC:ra0:$RA_MAIN_UP.Later we'll restart $(echo ${RESET_IF} | tr '\n' ' ')"
-	sleep 1
+	if lock -n $WIFI_OP_LOCK; then
+		sleep 3
+		RA_MAIN_UP=$(get_if_stat ra0)
+		drv_mt_dbdc_teardown $phy_name
+		RESET_IF=$(mt_dbdc_vif_down $phy_name)
+		echo "MT_DBDC:ra0:$RA_MAIN_UP.Later we'll restart $(echo ${RESET_IF} | tr '\n' ' ')"
+		sleep 1
 
 #Start root device
-	[ "$phy_name" == "rax0" ] && ifconfig ra0 up
+		ifconfig ra0 up
 #restore interfaces
-	[ -z "$RESET_IF" ] || {
-		for i in $RESET_IF
-		do
-			ifconfig $i up
-		done
 		sh $RTWIFI_CMD_OPATH
-	}
+
+		sh $RTWIFI_CMD_PATH
+#重启HWNAT
+		[ -d /sys/module/hw_nat ] && {
+			/etc/init.d/hwacc restart
+		}
+	else
+		echo "Wait other process"
+		lock $WIFI_OP_LOCK
+	fi
 #AP模式
 	ApIfCNT=0
 	for_each_interface "ap" mt_dbdc_ap_vif_post_config
@@ -863,14 +885,8 @@ EOF
 	for_each_interface "wds" mt_dbdc_wds_vif_post_config
 #STA模式
 	stacount=0
-	for_each_interface "sta" mt_dbdc_sta_vif_connect
-
-	[ "$phy_name" == "rax0" ] && [ "$RA_MAIN_UP" == "down" ] && ifconfig ra0 down
+	for_each_interface "sta" mt_dbdc_sta_vif_post_config
 
-#重启HWNAT
-	[ -d /sys/module/hw_nat ] && {
-		/etc/init.d/hwacc restart
-	}
 #设置无线上线
 	wireless_set_up
 #解锁

From 7deabe996f003a716844c4a26472f2ca5afe1fe3 Mon Sep 17 00:00:00 2001
From: jjm2473 <1129525450@qq.com>
Date: Tue, 1 Dec 2020 21:15:37 +0800
Subject: [PATCH 12/20] mt7615: fix bug

---
 .../lean/mt/drivers/mt7615d/files/lib/netifd/wireless/mt_dbdc.sh | 1 -
 1 file changed, 1 deletion(-)

diff --git a/package/feeds/custom/mt7615d/files/lib/netifd/wireless/mt_dbdc.sh b/package/feeds/custom/mt7615d/files/lib/netifd/wireless/mt_dbdc.sh
index 8bec004353f..b34660ec3a2 100644
--- a/package/feeds/custom/mt7615d/files/lib/netifd/wireless/mt_dbdc.sh
+++ b/package/feeds/custom/mt7615d/files/lib/netifd/wireless/mt_dbdc.sh
@@ -28,7 +28,6 @@ RTWIFI_DEF_MAX_BSSID=4
 
 mt_cmd() {
 	echo "$@" >> $RTWIFI_CMD_PATH
-	eval $@
 }
 
 #读取device相关设置项并写入json

From d7c645949b8b69df1c9b1f9b3260216523ca937b Mon Sep 17 00:00:00 2001
From: jjm2473 <1129525450@qq.com>
Date: Tue, 1 Dec 2020 21:16:55 +0800
Subject: [PATCH 13/20] mt7615: fix isolate

---
 package/feeds/custom/mt7615d/Makefile                       | 3 ++-
 .../drivers/mt7615d/files/etc/uci-defaults/mt7615-fix-isolate  | 3 +++
 2 files changed, 5 insertions(+), 1 deletion(-)
 create mode 100644 package/feeds/custom/mt7615d/files/etc/uci-defaults/mt7615-fix-isolate

diff --git a/package/feeds/custom/mt7615d/Makefile b/package/feeds/custom/mt7615d/Makefile
index 8fa98118ae4..0f641e39483 100644
--- a/package/feeds/custom/mt7615d/Makefile
+++ b/package/feeds/custom/mt7615d/Makefile
@@ -220,9 +220,10 @@ define Build/Install
 endef
 
 define KernelPackage/mt7615d/install
-	$(INSTALL_DIR) $(1)/lib/wifi $(1)/lib/netifd/wireless
+	$(INSTALL_DIR) $(1)/lib/wifi $(1)/lib/netifd/wireless $(1)/etc/uci-defaults
 	$(INSTALL_DATA) ./files/lib/wifi/mt_dbdc.sh $(1)/lib/wifi
 	$(INSTALL_BIN) ./files/lib/netifd/wireless/mt_dbdc.sh $(1)/lib/netifd/wireless
+	$(INSTALL_DATA) ./files/etc/uci-defaults/mt7615-fix-isolate $(1)/etc/uci-defaults/mt7615-fix-isolate
 endef
 
 $(eval $(call KernelPackage,mt7615d))
diff --git a/package/feeds/custom/mt7615d/files/etc/uci-defaults/mt7615-fix-isolate b/package/feeds/custom/mt7615d/files/etc/uci-defaults/mt7615-fix-isolate
new file mode 100644
index 00000000000..023e2c02d27
--- /dev/null
+++ b/package/feeds/custom/mt7615d/files/etc/uci-defaults/mt7615-fix-isolate
@@ -0,0 +1,3 @@
+#!/bin/sh
+
+sed -i 's/multicast_to_unicast:-1/multicast_to_unicast:-0/g' /lib/netifd/netifd-wireless.sh

From 61fe1fb50a523d1cbe302ef04c177f14a2f9f94d Mon Sep 17 00:00:00 2001
From: jjm2473 <1129525450@qq.com>
Date: Tue, 1 Dec 2020 21:19:30 +0800
Subject: [PATCH 14/20] mt7615: clean code

---
 package/feeds/custom/mt7615d/config.in              |  5 ++---
 .../mt7615d/src/mt_wifi/embedded/common/cmm_info.c     | 10 +++++-----
 .../mt7615d/src/mt_wifi/embedded/security/cmm_wpa.c    |  4 ++--
 3 files changed, 9 insertions(+), 10 deletions(-)

diff --git a/package/feeds/custom/mt7615d/config.in b/package/feeds/custom/mt7615d/config.in
index 0c71a2da15d..005910b2da2 100644
--- a/package/feeds/custom/mt7615d/config.in
+++ b/package/feeds/custom/mt7615d/config.in
@@ -273,8 +273,7 @@ config MTK_HDR_TRANS_RX_SUPPORT
 config MTK_DBDC_MODE
 	bool "dbdc mode support"
 	depends on MTK_CHIP_MT7615E || MTK_CHIP_MT7626
-	select MULTI_PROFILE_SUPPORT
-	select DEFAULT_5G_PROFILE
+	select MTK_MULTI_PROFILE_SUPPORT
 	default y if TARGET_ramips_mt7621_DEVICE_jcg_y2
 	default y if TARGET_ramips_mt7621_DEVICE_phicomm_k2p
 	default n
@@ -291,7 +290,7 @@ config MTK_DEFAULT_5G_PROFILE
 	depends on MTK_DBDC_MODE
 #	depends on MTK_MULTI_PROFILE_SUPPORT
 	default y if TARGET_ramips_mt7621_DEVICE_jcg_y2
-	default y if TARGET_ramips_mt7621_DEVICE_phicomm_k2p
+#	default y if TARGET_ramips_mt7621_DEVICE_phicomm_k2p
 	default n
 
 config MTK_WSC_INCLUDED
diff --git a/package/feeds/custom/mt7615d/src/mt_wifi/embedded/common/cmm_info.c b/package/feeds/custom/mt7615d/src/mt_wifi/embedded/common/cmm_info.c
index 74ea4dc9633..04d6f0fb46c 100644
--- a/package/feeds/custom/mt7615d/src/mt_wifi/embedded/common/cmm_info.c
+++ b/package/feeds/custom/mt7615d/src/mt_wifi/embedded/common/cmm_info.c
@@ -4661,6 +4661,11 @@ max_len += OWETRANSIE_LINE_LEN;
 
 	memset(msg, 0, TotalLen);
 
+	WaitCnt = 0;
+
+	while ((ScanRunning(pAdapter) == TRUE) && (WaitCnt++ < 200))
+		OS_WAIT(500);
+
 	if (pAdapter->ScanTab.BssNr == 0) {
 		sprintf(msg, "No BssInfo\n");
 		wrq->u.data.length = strlen(msg);
@@ -4697,11 +4702,6 @@ max_len += OWETRANSIE_LINE_LEN;
 		sprintf(msg + strlen(msg) - 1, "%-10s\n", " OWETranIe");
 #endif /* APCLI_OWE_SUPPORT */
 
-	WaitCnt = 0;
-
-	while ((ScanRunning(pAdapter) == TRUE) && (WaitCnt++ < 200))
-		OS_WAIT(500);
-
 
 	for (i = bss_start_idx; i < pAdapter->ScanTab.BssNr; i++) {
 		pBss = &pAdapter->ScanTab.BssEntry[i];
diff --git a/package/feeds/custom/mt7615d/src/mt_wifi/embedded/security/cmm_wpa.c b/package/feeds/custom/mt7615d/src/mt_wifi/embedded/security/cmm_wpa.c
index afe86d7c8f6..73ba68d892d 100644
--- a/package/feeds/custom/mt7615d/src/mt_wifi/embedded/security/cmm_wpa.c
+++ b/package/feeds/custom/mt7615d/src/mt_wifi/embedded/security/cmm_wpa.c
@@ -5397,9 +5397,9 @@ VOID PeerPairMsg4Action(
 			MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_OFF, ("PTK:"));
 
 			for (i = 0; i < 64; i++)
-				MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_OFF, ("%02x", pSecConfig->PTK[i]));
+				MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_OFF, (KERN_CONT"%02x", pSecConfig->PTK[i]));
 
-			MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_OFF, ("\n"));
+			MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_OFF, (KERN_CONT"\n"));
 		}
 	} else {
 		/* 5. init Group 2-way handshake if necessary.*/

From de1a20509599c196d2653c150565c68face5f540 Mon Sep 17 00:00:00 2001
From: jjm2473 <1129525450@qq.com>
Date: Wed, 2 Dec 2020 00:07:02 +0800
Subject: [PATCH 15/20] mt7615: fix CE without cfg80211

---
 package/feeds/custom/mt7615d/Makefile  |  2 +-
 package/feeds/custom/mt7615d/config.in | 12 +-----------
 2 files changed, 2 insertions(+), 12 deletions(-)

diff --git a/package/feeds/custom/mt7615d/Makefile b/package/feeds/custom/mt7615d/Makefile
index 0f641e39483..cf33aa293de 100644
--- a/package/feeds/custom/mt7615d/Makefile
+++ b/package/feeds/custom/mt7615d/Makefile
@@ -210,7 +210,7 @@ define Build/Compile
 		$(KERNEL_MAKE_FLAGS) \
 		$(foreach c, $(PKG_KCONFIG),$(if $(CONFIG_MTK_$c),CONFIG_$(c)=$(CONFIG_MTK_$(c)))) \
 		M="$(PKG_BUILD_DIR)/mt_wifi_ap" \
-		NOSTDINC_FLAGS="$(NOSTDINC_FLAGS)" \
+		$(if $(CONFIG_MTK_CFG80211_SUPPORT),NOSTDINC_FLAGS="$(NOSTDINC_FLAGS)") \
 		V=1 \
 		modules
 endef
diff --git a/package/feeds/custom/mt7615d/config.in b/package/feeds/custom/mt7615d/config.in
index 005910b2da2..08ad4107ed0 100644
--- a/package/feeds/custom/mt7615d/config.in
+++ b/package/feeds/custom/mt7615d/config.in
@@ -275,22 +275,12 @@ config MTK_DBDC_MODE
 	depends on MTK_CHIP_MT7615E || MTK_CHIP_MT7626
 	select MTK_MULTI_PROFILE_SUPPORT
 	default y if TARGET_ramips_mt7621_DEVICE_jcg_y2
-	default y if TARGET_ramips_mt7621_DEVICE_phicomm_k2p
+	default y if TARGET_ramips_mt7621_DEVICE_phicomm_k2p || TARGET_DEVICE_ramips_mt7621_DEVICE_phicomm_k2p
 	default n
 
 config MTK_MULTI_PROFILE_SUPPORT
 	bool "Multi Profile Support"
 	depends on MTK_DBDC_MODE
-	default y if TARGET_ramips_mt7621_DEVICE_jcg_y2
-	default y if TARGET_ramips_mt7621_DEVICE_phicomm_k2p
-	default n
-
-config MTK_DEFAULT_5G_PROFILE
-	bool "5G default profile for DBDC"
-	depends on MTK_DBDC_MODE
-#	depends on MTK_MULTI_PROFILE_SUPPORT
-	default y if TARGET_ramips_mt7621_DEVICE_jcg_y2
-#	default y if TARGET_ramips_mt7621_DEVICE_phicomm_k2p
 	default n
 
 config MTK_WSC_INCLUDED

From 4c34306180041c713c2c469e88874d1a61d22bb7 Mon Sep 17 00:00:00 2001
From: jjm2473 <1129525450@qq.com>
Date: Wed, 2 Dec 2020 14:06:18 +0800
Subject: [PATCH 16/20] mt7615: split dbdc variant

---
 package/feeds/custom/mt7615d/Makefile      | 22 +++++++++++++++++
 .../src/mt_wifi/embedded/include/l1profile.h  | 24 ++++++++++++++++---
 .../mt7615d/src/mt_wifi/os/linux/ap_ioctl.c   |  4 ++--
 package/feeds/custom/mt_wifi/Makefile      |  2 +-
 package/feeds/custom/luci-app-mtwifi/Makefile      |  2 +-
 package/network/utils/iwinfo/Makefile         |  2 +-
 target/linux/ramips/image/mt7621.mk           |  4 ++--
 7 files changed, 50 insertions(+), 10 deletions(-)

diff --git a/package/feeds/custom/mt7615d/Makefile b/package/feeds/custom/mt7615d/Makefile
index cf33aa293de..add91e68766 100644
--- a/package/feeds/custom/mt7615d/Makefile
+++ b/package/feeds/custom/mt7615d/Makefile
@@ -197,6 +197,23 @@ define KernelPackage/mt7615d/config
 	source "$(SOURCE)/config.in"
 endef
 
+define KernelPackage/mt7615d_dbdc
+  CATEGORY:=Kernel modules
+  TITLE:=MTK wifi AP driver
+  DEPENDS:=@TARGET_ramips +kmod-mt7615d
+  SUBMENU:=Wireless Drivers
+  MENU:=1
+endef
+
+define KernelPackage/mt7615d_dbdc/config
+	select MTK_WIFI_DRIVER
+	select MTK_FIRST_IF_MT7615E
+	select MTK_MT_WIFI
+	select MTK_WIFI_MT_MAC
+	select MTK_CHIP_MT7615E
+	select MTK_DBDC_MODE
+endef
+
 NOSTDINC_FLAGS = \
 	-I$(STAGING_DIR)/usr/include/mac80211-backport/uapi \
 	-I$(STAGING_DIR)/usr/include/mac80211-backport \
@@ -220,6 +237,10 @@ define Build/Install
 endef
 
 define KernelPackage/mt7615d/install
+	:
+endef
+
+define KernelPackage/mt7615d_dbdc/install
 	$(INSTALL_DIR) $(1)/lib/wifi $(1)/lib/netifd/wireless $(1)/etc/uci-defaults
 	$(INSTALL_DATA) ./files/lib/wifi/mt_dbdc.sh $(1)/lib/wifi
 	$(INSTALL_BIN) ./files/lib/netifd/wireless/mt_dbdc.sh $(1)/lib/netifd/wireless
@@ -227,3 +248,4 @@ define KernelPackage/mt7615d/install
 endef
 
 $(eval $(call KernelPackage,mt7615d))
+$(eval $(call KernelPackage,mt7615d_dbdc))
diff --git a/package/feeds/custom/mt7615d/src/mt_wifi/embedded/include/l1profile.h b/package/feeds/custom/mt7615d/src/mt_wifi/embedded/include/l1profile.h
index ee352ab23c7..1c53d5dd2cd 100644
--- a/package/feeds/custom/mt7615d/src/mt_wifi/embedded/include/l1profile.h
+++ b/package/feeds/custom/mt7615d/src/mt_wifi/embedded/include/l1profile.h
@@ -1,3 +1,4 @@
+#ifdef DBDC_MODE
 UCHAR l1profile_default[] = {
 "Default\n\
 INDEX0=MT7615\n\
@@ -12,9 +13,26 @@ INDEX0_apcli_ifname=apcli;apclix\n\
 INDEX0_mesh_ifname=mesh;meshx\n\
 INDEX0_nvram_zone=RT2860\n\
 INDEX0_single_sku_path=/etc_ro/Wireless/RT2860AP/SingleSKU.dat\n\
+INDEX0_bf_sku_path=/etc_ro/Wireless/RT2860AP/SingleSKU_BF.dat\n"
+};
+
+#else
+
+UCHAR l1profile_default[] = {
+"Default\n\
+INDEX0=MT7615\n\
+INDEX0_profile_path=/etc/wireless/mt7615/mt7615.1.dat\n\
+INDEX0_EEPROM_offset=0x0\n\
+INDEX0_EEPROM_size=0x4000\n\
+INDEX0_EEPROM_name=e2p\n\
+INDEX0_main_ifname=ra0\n\
+INDEX0_ext_ifname=ra\n\
+INDEX0_wds_ifname=wds\n\
+INDEX0_apcli_ifname=apcli\n\
+INDEX0_single_sku_path=/etc_ro/Wireless/RT2860AP/SingleSKU.dat\n\
 INDEX0_bf_sku_path=/etc_ro/Wireless/RT2860AP/SingleSKU_BF.dat\n\
 INDEX1=MT7615\n\
-INDEX1_profile_path=/etc/Wireless/iNIC/iNIC_ap.dat\n\
+INDEX1_profile_path=/etc/wireless/mt7615/mt7615.2.dat\n\
 INDEX1_EEPROM_offset=0x8000\n\
 INDEX1_EEPROM_size=0x4000\n\
 INDEX1_EEPROM_name=e2p\n\
@@ -22,8 +40,8 @@ INDEX1_main_ifname=rai0\n\
 INDEX1_ext_ifname=rai\n\
 INDEX1_wds_ifname=wdsi\n\
 INDEX1_apcli_ifname=apclii\n\
-INDEX1_mesh_ifname=meshi\n\
-INDEX1_nvram_zone=RTDEV\n\
 INDEX1_single_sku_path=/etc_ro/Wireless/RT2860AP/SingleSKU.dat\n\
 INDEX1_bf_sku_path=/etc_ro/Wireless/RT2860AP/SingleSKU_BF.dat\n"
 };
+
+#endif
\ No newline at end of file
diff --git a/package/feeds/custom/mt7615d/src/mt_wifi/os/linux/ap_ioctl.c b/package/feeds/custom/mt7615d/src/mt_wifi/os/linux/ap_ioctl.c
index 71b3a3d4aa0..daa1f617296 100644
--- a/package/feeds/custom/mt7615d/src/mt_wifi/os/linux/ap_ioctl.c
+++ b/package/feeds/custom/mt7615d/src/mt_wifi/os/linux/ap_ioctl.c
@@ -63,7 +63,7 @@ struct iw_priv_args ap_privtab[] = {
 	},
 	{
 		RTPRIV_IOCTL_GSITESURVEY,
-		IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | 1024,
+		IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK,
 		"get_site_survey"
 	},
 	{
@@ -83,7 +83,7 @@ struct iw_priv_args ap_privtab[] = {
 	},
 	{
 		RTPRIV_IOCTL_E2P,
-		IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | 1024,
+		IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK,
 		"e2p"
 	},
 #if defined(DBG) || (defined(BB_SOC) && defined(CONFIG_ATE))
diff --git a/package/feeds/custom/mt_wifi/Makefile b/package/feeds/custom/mt_wifi/Makefile
index 57d8d6c932e..4064ae8a7a5 100644
--- a/package/feeds/custom/mt_wifi/Makefile
+++ b/package/feeds/custom/mt_wifi/Makefile
@@ -22,7 +22,7 @@ define Package/mt_wifi
   CATEGORY:=Network
   TITLE:=MTK wifi AP config
   DEPENDS:=@TARGET_ramips +wireless-tools
-  CONFLICTS:=kmod-mt7615d
+  CONFLICTS:=kmod-mt7615d_dbdc
   SUBMENU:=Wireless
 endef
 
diff --git a/package/feeds/custom/luci-app-mtwifi/Makefile b/package/feeds/custom/luci-app-mtwifi/Makefile
index dfeb286370d..6bc95cd68be 100644
--- a/package/feeds/custom/luci-app-mtwifi/Makefile
+++ b/package/feeds/custom/luci-app-mtwifi/Makefile
@@ -4,7 +4,7 @@ PKG_LICENSE:=GPLv2
 PKG_MAINTAINER:=Hua Shao <nossiac@163.com>
 
 LUCI_TITLE:=LuCI support for mt wifi driver
-LUCI_DEPENDS:=@TARGET_ramips +mt_wifi @!PACKAGE_kmod-mt7615d
+LUCI_DEPENDS:=@TARGET_ramips +mt_wifi @!PACKAGE_kmod-mt7615d_dbdc
 LUCI_PKGARCH:=all
 PKG_VERSION:=1
 PKG_RELEASE:=16
diff --git a/package/network/utils/iwinfo/Makefile b/package/network/utils/iwinfo/Makefile
index 46100efc037..fa0f68f2a89 100644
--- a/package/network/utils/iwinfo/Makefile
+++ b/package/network/utils/iwinfo/Makefile
@@ -75,7 +75,7 @@ IWINFO_BACKENDS := \
 	$(if $(CONFIG_PACKAGE_kmod-brcm-wl),wl) \
 	$(if $(CONFIG_PACKAGE_kmod-brcm-wl-mini),wl) \
 	$(if $(CONFIG_PACKAGE_kmod-brcm-wl-mimo),wl) \
-	$(if $(CONFIG_PACKAGE_kmod-mt7615d),ra) \
+	$(if $(CONFIG_PACKAGE_kmod-mt7615d_dbdc),ra) \
 	$(if $(CONFIG_PACKAGE_kmod-cfg80211),nl80211)
 
 TARGET_CFLAGS += \
diff --git a/target/linux/ramips/image/mt7621.mk b/target/linux/ramips/image/mt7621.mk
index 9f0d4d62b27..c08846f8851 100644
--- a/target/linux/ramips/image/mt7621.mk
+++ b/target/linux/ramips/image/mt7621.mk
@@ -508,7 +508,7 @@ define Device/jcg_y2
   JCG_MAXSIZE := 16064k
   DEVICE_VENDOR := JCG
   DEVICE_MODEL := Y2
-  DEVICE_PACKAGES := kmod-mt7615d kmod-usb3 luci-app-mtwifi
+  DEVICE_PACKAGES := kmod-mt7615d_dbdc kmod-usb3
 endef
 TARGET_DEVICES += jcg_y2
 
@@ -817,7 +817,7 @@ define Device/phicomm_k2p
   DEVICE_VENDOR := Phicomm
   DEVICE_MODEL := K2P
   SUPPORTED_DEVICES += k2p
-  DEVICE_PACKAGES := kmod-mt7615d
+  DEVICE_PACKAGES := kmod-mt7615d_dbdc
 endef
 TARGET_DEVICES += phicomm_k2p
 

From 35d2dc148896d4f897f2add5ee0b0ae57573a952 Mon Sep 17 00:00:00 2001
From: jjm2473 <1129525450@qq.com>
Date: Wed, 2 Dec 2020 15:02:46 +0800
Subject: [PATCH 17/20] mt7615: revert config for non dbdc variant devices

---
 package/feeds/custom/mt7615d/config.in | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/package/feeds/custom/mt7615d/config.in b/package/feeds/custom/mt7615d/config.in
index 08ad4107ed0..a5339ee7dcb 100644
--- a/package/feeds/custom/mt7615d/config.in
+++ b/package/feeds/custom/mt7615d/config.in
@@ -283,6 +283,14 @@ config MTK_MULTI_PROFILE_SUPPORT
 	depends on MTK_DBDC_MODE
 	default n
 
+config MTK_DEFAULT_5G_PROFILE
+	bool "5G default profile for DBDC"
+	depends on MTK_DBDC_MODE
+	depends on !PACKAGE_kmod-mt7615d_dbdc
+	default y if TARGET_ramips_mt7621_DEVICE_jcg_y2
+	default y if TARGET_ramips_mt7621_DEVICE_phicomm_k2p || TARGET_DEVICE_ramips_mt7621_DEVICE_phicomm_k2p
+	default n
+
 config MTK_WSC_INCLUDED
 	bool "WSC (WiFi Simple Config)"
 	depends on MTK_WIFI_DRIVER

From 22f6e16397f6bcb43ef60247ed290506bdedb514 Mon Sep 17 00:00:00 2001
From: jjm2473 <1129525450@qq.com>
Date: Wed, 2 Dec 2020 15:23:28 +0800
Subject: [PATCH 18/20] mt7615: move maccalc dependency to dbdc variant

---
 package/feeds/custom/mt7615d/Makefile | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/package/feeds/custom/mt7615d/Makefile b/package/feeds/custom/mt7615d/Makefile
index add91e68766..ec00e9e9c4f 100644
--- a/package/feeds/custom/mt7615d/Makefile
+++ b/package/feeds/custom/mt7615d/Makefile
@@ -181,7 +181,7 @@ include $(INCLUDE_DIR)/package.mk
 define KernelPackage/mt7615d
   CATEGORY:=Kernel modules
   TITLE:=MTK wifi AP driver
-  DEPENDS:=@TARGET_ramips +maccalc +MTK_CFG80211_SUPPORT:kmod-cfg80211 +@DRIVER_11AC_SUPPORT +@DRIVER_11N_SUPPORT +@DRIVER_11W_SUPPORT
+  DEPENDS:=@TARGET_ramips +MTK_CFG80211_SUPPORT:kmod-cfg80211 +@DRIVER_11AC_SUPPORT +@DRIVER_11N_SUPPORT +@DRIVER_11W_SUPPORT
 ifneq ($(CONFIG_MTK_WHNAT_SUPPORT), )
   FILES:=$(PKG_BUILD_DIR)/mt_wifi_ap/mt_wifi.ko \
 	$(PKG_BUILD_DIR)/mt_wifi/embedded/tools/plug_in/whnat/mt_whnat.ko
@@ -200,7 +200,7 @@ endef
 define KernelPackage/mt7615d_dbdc
   CATEGORY:=Kernel modules
   TITLE:=MTK wifi AP driver
-  DEPENDS:=@TARGET_ramips +kmod-mt7615d
+  DEPENDS:=@TARGET_ramips +kmod-mt7615d +maccalc
   SUBMENU:=Wireless Drivers
   MENU:=1
 endef

From 58056dd695b07714dd4a381352c0946b17180a54 Mon Sep 17 00:00:00 2001
From: jjm2473 <1129525450@qq.com>
Date: Wed, 2 Dec 2020 17:26:24 +0800
Subject: [PATCH 19/20] mt7615: append author info

---
 .../lean/mt/drivers/mt7615d/files/lib/netifd/wireless/mt_dbdc.sh | 1 +
 1 file changed, 1 insertion(+)

diff --git a/package/feeds/custom/mt7615d/files/lib/netifd/wireless/mt_dbdc.sh b/package/feeds/custom/mt7615d/files/lib/netifd/wireless/mt_dbdc.sh
index b34660ec3a2..394544f52f2 100644
--- a/package/feeds/custom/mt7615d/files/lib/netifd/wireless/mt_dbdc.sh
+++ b/package/feeds/custom/mt7615d/files/lib/netifd/wireless/mt_dbdc.sh
@@ -4,6 +4,7 @@
 # Copyright (c) 2005-2015, lintel <lintel.huang@gmail.com>
 # Copyright (c) 2013, Hoowa <hoowa.sun@gmail.com>
 # Copyright (c) 2015-2017, GuoGuo <gch981213@gmail.com>
+# Copyright (c) 2020, jjm2473 <jjm2473@gmail.com>
 #
 # 	netifd config script for MT7615 DBDC mode.
 #

From 08de1fdca9a2d45eb649102ce3c30633c5ca15de Mon Sep 17 00:00:00 2001
From: jjm2473 <1129525450@qq.com>
Date: Thu, 3 Dec 2020 17:51:34 +0800
Subject: [PATCH 20/20] mt7615: move config generation to uci-defaults

---
 package/base-files/files/etc/init.d/boot                 | 1 -
 package/feeds/custom/mt7615d/Makefile                 | 2 +-
 .../mt7615d/files/etc/uci-defaults/10_mt7615_dbdc        | 9 +++++++++
 .../mt7615d/files/etc/uci-defaults/mt7615-fix-isolate    | 3 ---
 package/network/utils/iwinfo/Makefile                    | 1 +
 5 files changed, 11 insertions(+), 5 deletions(-)
 create mode 100644 package/feeds/custom/mt7615d/files/etc/uci-defaults/10_mt7615_dbdc
 delete mode 100644 package/feeds/custom/mt7615d/files/etc/uci-defaults/mt7615-fix-isolate

diff --git a/package/base-files/files/etc/init.d/boot b/package/base-files/files/etc/init.d/boot
index d947895cfa8..21aecde615d 100755
--- a/package/base-files/files/etc/init.d/boot
+++ b/package/base-files/files/etc/init.d/boot
@@ -42,7 +42,6 @@ boot() {
 	[ ! -f /etc/config/wireless ] && {
 		# compat for bcm47xx and mvebu
 		sleep 1
-		/sbin/wifi config
 	}
 
 	/bin/config_generate
diff --git a/package/feeds/custom/mt7615d/Makefile b/package/feeds/custom/mt7615d/Makefile
index ec00e9e9c4f..58e01810280 100644
--- a/package/feeds/custom/mt7615d/Makefile
+++ b/package/feeds/custom/mt7615d/Makefile
@@ -244,7 +244,7 @@ define KernelPackage/mt7615d_dbdc/install
 	$(INSTALL_DIR) $(1)/lib/wifi $(1)/lib/netifd/wireless $(1)/etc/uci-defaults
 	$(INSTALL_DATA) ./files/lib/wifi/mt_dbdc.sh $(1)/lib/wifi
 	$(INSTALL_BIN) ./files/lib/netifd/wireless/mt_dbdc.sh $(1)/lib/netifd/wireless
-	$(INSTALL_DATA) ./files/etc/uci-defaults/mt7615-fix-isolate $(1)/etc/uci-defaults/mt7615-fix-isolate
+	$(INSTALL_DATA) ./files/etc/uci-defaults/10_mt7615_dbdc $(1)/etc/uci-defaults/10_mt7615_dbdc
 endef
 
 $(eval $(call KernelPackage,mt7615d))
diff --git a/package/feeds/custom/mt7615d/files/etc/uci-defaults/10_mt7615_dbdc b/package/feeds/custom/mt7615d/files/etc/uci-defaults/10_mt7615_dbdc
new file mode 100644
index 00000000000..3bad18d41ea
--- /dev/null
+++ b/package/feeds/custom/mt7615d/files/etc/uci-defaults/10_mt7615_dbdc
@@ -0,0 +1,9 @@
+#!/bin/sh
+
+# fix isolate
+sed -i 's/multicast_to_unicast:-1/multicast_to_unicast:-0/g' /lib/netifd/netifd-wireless.sh
+
+# generate default wireless config
+[ ! -f /etc/config/wireless ] && /sbin/wifi config
+
+exit 0
diff --git a/package/feeds/custom/mt7615d/files/etc/uci-defaults/mt7615-fix-isolate b/package/feeds/custom/mt7615d/files/etc/uci-defaults/mt7615-fix-isolate
deleted file mode 100644
index 023e2c02d27..00000000000
--- a/package/feeds/custom/mt7615d/files/etc/uci-defaults/mt7615-fix-isolate
+++ /dev/null
@@ -1,3 +0,0 @@
-#!/bin/sh
-
-sed -i 's/multicast_to_unicast:-1/multicast_to_unicast:-0/g' /lib/netifd/netifd-wireless.sh
diff --git a/package/network/utils/iwinfo/Makefile b/package/network/utils/iwinfo/Makefile
index fa0f68f2a89..0f8b7f6b76f 100644
--- a/package/network/utils/iwinfo/Makefile
+++ b/package/network/utils/iwinfo/Makefile
@@ -23,6 +23,7 @@ PKG_CONFIG_DEPENDS := \
 	CONFIG_PACKAGE_kmod-brcm-wl \
 	CONFIG_PACKAGE_kmod-brcm-wl-mini \
 	CONFIG_PACKAGE_kmod-brcm-wl-mimo \
+	CONFIG_PACKAGE_kmod-mt7615d_dbdc \
 	CONFIG_PACKAGE_kmod-cfg80211
 
 include $(INCLUDE_DIR)/package.mk
